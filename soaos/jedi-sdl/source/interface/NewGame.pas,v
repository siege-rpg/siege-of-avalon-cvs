head	1.13;
access;
symbols;
locks; strict;
comment	@ * @;


1.13
date	2005.06.13.23.22.06;	author savage;	state Exp;
branches;
next	1.12;

1.12
date	2005.06.02.22.51.54;	author savage;	state Exp;
branches;
next	1.11;

1.11
date	2005.06.01.20.24.27;	author savage;	state Exp;
branches;
next	1.10;

1.10
date	2005.05.28.16.31.28;	author savage;	state Exp;
branches;
next	1.9;

1.9
date	2005.05.28.09.56.10;	author savage;	state Exp;
branches;
next	1.8;

1.8
date	2005.05.25.23.15.42;	author savage;	state Exp;
branches;
next	1.7;

1.7
date	2005.05.13.20.09.30;	author savage;	state Exp;
branches;
next	1.6;

1.6
date	2005.05.13.12.33.15;	author savage;	state Exp;
branches;
next	1.5;

1.5
date	2005.05.08.14.43.59;	author savage;	state Exp;
branches;
next	1.4;

1.4
date	2005.05.06.08.18.54;	author savage;	state Exp;
branches;
next	1.3;

1.3
date	2005.04.30.14.00.00;	author savage;	state Exp;
branches;
next	1.2;

1.2
date	2004.10.17.18.38.06;	author savage;	state Exp;
branches;
next	1.1;

1.1
date	2004.09.30.22.49.20;	author savage;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Mouse over hints for PickLists now implemented.
@
text
@unit NewGame;
{******************************************************************************}
{
  $Id: NewGame.pas,v 1.12 2005/06/02 22:51:54 savage Exp $

}
{                                                                              }
{               Siege Of Avalon : Open Source Edition                          }
{               -------------------------------------                          }
{                                                                              }
{ Portions created by Digital Tome L.P. Texas USA are                          }
{ Copyright ©1999-2000 Digital Tome L.P. Texas USA                             }
{ All Rights Reserved.                                                         }
{                                                                              }
{ Portions created by Team SOAOS are                                           }
{ Copyright (C) 2003 - Team SOAOS.                                             }
{                                                                              }
{                                                                              }
{ Contributor(s)                                                               }
{ --------------                                                               }
{ Dominique Louis <Dominique@@SavageSoftware.com.au>                            }
{                                                                              }
{                                                                              }
{                                                                              }
{ You may retrieve the latest version of this file at the SOAOS project page : }
{   http://www.sourceforge.com/projects/soaos                                  }
{                                                                              }
{ The contents of this file maybe used with permission, subject to             }
{ the GNU Lesser General Public License Version 2.1 (the "License"); you may   }
{ not use this file except in compliance with the License. You may             }
{ obtain a copy of the License at                                              }
{ http://www.opensource.org/licenses/lgpl-license.php                          }
{                                                                              }
{ Software distributed under the License is distributed on an                  }
{ "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or               }
{ implied. See the License for the specific language governing                 }
{ rights and limitations under the License.                                    }
{                                                                              }
{ Description                                                                  }
{ -----------                                                                  }
{                                                                              }
{                                                                              }
{                                                                              }
{                                                                              }
{                                                                              }
{                                                                              }
{                                                                              }
{ Requires                                                                     }
{ --------                                                                     }
{   SDL ( http://www.libsdl.org ) and DirectX ( http://www.microsoft.com )     }
{   Runtime libraris on Win32 and just SDL ( http://www.libsdl.org ) shared    }
{   objects or their equivalents on Linux and other Unixes                     }
{                                                                              }
{ Programming Notes                                                            }
{ -----------------                                                            }
{   Should compile with Delphi, Kylix and FreePascal on Win32 and Linux for    }
{   starter and FreeBSD and MacOS X etc there after.                           }
{                                                                              }
{                                                                              }
{ Revision History                                                             }
{ ----------------                                                             }
{   September   30 2004 - DL : Initial Creation                                }
{                                                                              }
{
  $Log: NewGame.pas,v $
  Revision 1.12  2005/06/02 22:51:54  savage
  More Cross-Platform additions and amendments

  Revision 1.11  2005/06/01 20:24:27  savage
  Fix for Linux case sensitivity issues

  Revision 1.10  2005/05/28 16:31:28  savage
  StatChanges are now reflected, You cannot click Continue unless TrainingPoints are 0 and you have entered a CharacterName

  Revision 1.9  2005/05/28 09:56:10  savage
  Get Selections working correctly.

  Revision 1.8  2005/05/25 23:15:42  savage
  Latest Changes

  Revision 1.7  2005/05/13 20:09:30  savage
  Changed so that german Continue appears correctly.

  Revision 1.6  2005/05/13 12:33:15  savage
  Various Changes and bug fixes. Main work on the NewGame screen.

  Revision 1.5  2005/05/08 14:43:59  savage
  Added Exception Logging

  Revision 1.4  2005/05/06 08:18:54  savage
  ListBoxDialog used in New GUI

  Revision 1.2  2004/10/17 18:38:06  savage
  Initial changes to stop it crashing on exit.

  Revision 1.1  2004/09/30 22:49:20  savage
  Initial Game Interface units.


}
{******************************************************************************}

interface

uses
  sdl,
  SiegeInterfaces,
  SiegeTypes{,
  Character};

type
  TMouseOverNewOptions = (
    moTrainingPoints,
    moPrimarySkill, // No longer used
    moStrength,
    moCoordination,
    moConstitution,
    moPerception,
    moCharm,
    moMysticism,
    moCombat,
    moStealth,
    moCharacterName,
    moAppearance,
    moShirtColour,
    moPantsColour,
    moHairColour,
    moHairStyle,
    moBeard,
    moTrainingStyle,
    moStrengthMinus,
    moCoordinationMinus,
    moConstitutionMinus,
    moPerceptionMinus,
    moCharmMinus,
    moMysticismMinus,
    moCombatMinus,
    moStealthMinus,
    moStrengthPlus,
    moCoordinationPlus,
    moConstitutionPlus,
    moPerceptionPlus,
    moCharmPlus,
    moMysticismPlus,
    moCombatPlus,
    moStealthPlus,
    moFighter,
    moScout,
    moMagician,
    moBlueShirt,
    moContinue,
    moCancel,
    moLeftArrow,
    moRightArrow,
    moNone );

  TRenderMode = ( rmNormal, rmPickList );

  TInformationRect = record
    FRect : TSDL_Rect;
    FInfo : PSDL_Surface;
  end;

  TSelectableRect = record
    FRect : TSDL_Rect;
    FInfo : PSDL_Surface;
    FText : PSDL_Surface;
  end;

  TCharacter = class
  private
    FName: string;
    FBaseAttackRecovery: Integer;
    FBaseMysticism: Integer;
    FBaseConstitution: Integer;
    FBaseCombat: Integer;
    FBaseHitRecovery: integer;
    FBaseHealingRate: Integer;
    FBaseRechargeRate: Integer;
    FBaseCoordination: Integer;
    FBaseCharm: Integer;
    FBaseStrength: Integer;
    FTrainingPoints: Integer;
    FBasePerception: Integer;
    FBaseStealth: Integer;
    FBaseMana: Single;
    FBaseMovement: Single;
    FBaseDefense: Single;
    FBaseAttackBonus: Single;
    FBaseHitPoints: Single;
    FDamage: TDamageProfile;
    FResistance: TDamageResistanceProfile;
    FStealth: Integer;
    FCharm: Integer;
    FMysticism: Integer;
    FPerception: Integer;
    FCoordination: Integer;
    FCombat: Integer;
    FConstitution: Integer;
    FStrength: Integer;
    FMovement: Single;
  public
    property BaseStrength : Integer read FBaseStrength write FBaseStrength;
    property BaseCoordination : Integer read FBaseCoordination write FBaseCoordination;
    property BaseConstitution : Integer read FBaseConstitution write FBaseConstitution;
    property BaseMysticism : Integer read FBaseMysticism write FBaseMysticism;
    property BaseCombat : Integer read FBaseCombat write FBaseCombat;
    property BaseStealth : Integer read FBaseStealth write FBaseStealth;
    property BaseMovement : Single read FBaseMovement write FBaseMovement;
    property BasePerception : Integer read FBasePerception write FBasePerception;
    property BaseCharm : Integer read FBaseCharm write FBaseCharm;
    property Strength : Integer read FStrength write FStrength;
    property Coordination : Integer read FCoordination write FCoordination;
    property Constitution : Integer read FConstitution write FConstitution;
    property Mysticism : Integer read FMysticism write FMysticism;
    property Combat : Integer read FCombat write FCombat;
    property Stealth : Integer read FStealth write FStealth;
    property Movement : Single read FMovement write FMovement;
    property Perception : Integer read FPerception write FPerception;
    property Charm : Integer read FCharm write FCharm;
    property BaseHealingRate : Integer read FBaseHealingRate write FBaseHealingRate;
    property BaseRechargeRate : Integer read FBaseRechargeRate write FBaseRechargeRate;
    property BaseHitPoints : Single read FBaseHitPoints write FBaseHitPoints;
    property BaseMana : Single read FBaseMana write FBaseMana;
    property BaseAttackRecovery : Integer read FBaseAttackRecovery write FBaseAttackRecovery;
    property BaseAttackBonus : Single read FBaseAttackBonus write FBaseAttackBonus;
    property BaseDefense : Single read FBaseDefense write FBaseDefense;
    property BaseHitRecovery : integer read FBaseHitRecovery write FBaseHitRecovery;
    property Damage : TDamageProfile read FDamage write FDamage;
    property Resistance : TDamageResistanceProfile read FResistance write FResistance;
    property TrainingPoints : Integer read FTrainingPoints write FTrainingPoints;
    constructor Create;
    property Name : string read FName write FName;
  end;

  TNewGame = class( TSimpleSoAInterface )
  private
    DXSelectRect : PSDL_Surface; // rectangle used for outline
    DXBlack : PSDL_Surface;
    DXContinue : PSDL_Surface;
    DXCancel : PSDL_Surface;
    DXLeftArrow, DXRightArrow : PSDL_Surface;
    DXPickList : PSDL_Surface;
    DXPlayerName : PSDL_Surface;
    TextMessage : array[ 0..104 ] of WideString;
    DXTextMessage : array[ 0..9 ] of PSDL_Surface;
    ContinueRect, CancelRect, LeftArrowRect, RightArrowRect, OKRect : TSDL_Rect;
    InfoPanel : TSDL_Rect;
    MouseOverOptions : TMouseOverNewOptions;
    InfoRect : array[ 0..17 ] of TInformationRect; //was 35  //collision rects for information
    ArrowRect : array[ 0..15 ] of TInformationRect; //collision rects for arrows
    StatRect : array[ 0..8 ] of TInformationRect; //collision rects for arrows
    //StatAdjustments : array[ 0..7 ] of integer; //used to see if we've added points to a stat or not
    StatName : array[ 0..1, 0..11 ] of WideString;
    SelectRect : array[ 0..20 ] of TSelectableRect; //collision rects for selectable text
    //base stuff - saved in case we do a cancel
   { Damage : TDamageProfile;
    Resistance : TDamageResistanceProfile;
    BaseStrength : integer;
    BaseCoordination : integer;
    BaseConstitution : integer;
    BasePerception : integer;
    BaseCharm : integer;
    BaseMysticism : integer;
    BaseCombat : integer;
    BaseStealth : integer;
    TrainingPoints : integer; }
    ixSelectedShirt : integer; //current selected shirt color
    ixSelectedPants : integer; //current selected pants color
    ixSelectedHair : integer; //current selected Hair color
    ixSelectedHairStyle : integer; //current selected Hairstyle
    ixSelectedBeard : integer;
    ixSelectedTraining : integer;
    RenderMode : TRenderMode;
    iPickListLow, iPickListHigh, moItem : integer;
    procedure LoadBaseValues; //saves the base stats of the character
    procedure LoadNames;
    procedure CreateCollisionRects; //create the rects for the collision detection
    procedure ReCreateStats;
  public
    procedure FreeSurfaces; override;
    procedure LoadSurfaces; override;
    procedure KeyDown( var Key : TSDLKey; Shift : TSDLMod; unicode : UInt16 ); override;
    procedure MouseDown( Button : Integer; Shift : TSDLMod; CurrentPos : TPoint ); override;
    procedure MouseMove( Shift : TSDLMod; CurrentPos : TPoint; RelativePos : TPoint ); override;
    procedure Render; override;
    procedure Update( aElapsedTime : single ); override;
  end;

implementation

uses
  SysUtils,
  xplatformutils,
  logger,
  globals,
  GameMainMenu,
  ListBoxDialog,
  sdlgameinterface,
  Math;

{ TNewGame }

procedure TNewGame.CreateCollisionRects;
const
  FailName : string = 'TNewGame.CreateCollisionRects';
  Flags : Cardinal = SDL_SRCCOLORKEY or SDL_RLEACCEL or SDL_HWACCEL;
var
  i, j : integer;
  LineHeight : integer;
begin
  try
    LineHeight := 24;
     //first the ArrowRects
    for i := 0 to 7 do
    begin
      ArrowRect[ i ].FRect.x := 389;
      ArrowRect[ i + 8 ].FRect.x := 408;
      ArrowRect[ i ].FRect.w := 406 - ArrowRect[ i ].FRect.x;
      ArrowRect[ i + 8 ].FRect.w := 425 - ArrowRect[ i + 8 ].FRect.x;
      ArrowRect[ i ].FRect.y := 239 + i * LineHeight;
      ArrowRect[ i + 8 ].FRect.y := 239 + i * LineHeight;
      ArrowRect[ i ].FRect.h := ( 239 + i * LineHeight + LineHeight ) - ArrowRect[ i ].FRect.y;
      ArrowRect[ i + 8 ].FRect.h := ( 239 + i * LineHeight + LineHeight ) - ArrowRect[ i ].FRect.y;

      ArrowRect[ i ].FInfo := GameFont.DrawText( TextMessage[ 26 ] + StatName[ 0 ][ i + 1 ] + '.', InfoPanel.w, InfoPanel.h );
      SDL_SetColorKey( ArrowRect[ i ].FInfo, Flags, SDL_MapRGB( ArrowRect[ i ].FInfo.format, 0, 0, 0 ) );

      if i < 5 then
      begin
        ArrowRect[ i + 8 ].FInfo := GameFont.DrawText( TextMessage[ 27 ] + StatName[ 0 ][ i + 1 ] + TextMessage[ 28 ] + StatName[ 0 ][ i + 1 ] + TextMessage[ 29 ], InfoPanel.w, InfoPanel.h );
        SDL_SetColorKey( ArrowRect[ i + 8 ].FInfo, Flags, SDL_MapRGB( ArrowRect[ i + 8 ].FInfo.format, 0, 0, 0 ) );
      end
      else
      begin
        ArrowRect[ i + 8 ].FInfo := GameFont.DrawText( TextMessage[ 30 ] + StatName[ 0 ][ i + 1 ] + TextMessage[ 31 ] + StatName[ 0 ][ i + 1 ] + TextMessage[ 29 ], InfoPanel.w, InfoPanel.h );
        SDL_SetColorKey( ArrowRect[ i + 8 ].FInfo, Flags, SDL_MapRGB( ArrowRect[ i + 8 ].FInfo.format, 0, 0, 0 ) );
      end;

    end; //end for

     //Training points
    InfoRect[ 0 ].FRect.x := 298;
    InfoRect[ 0 ].FRect.y := 212;
    InfoRect[ 0 ].FRect.w := 457 - InfoRect[ 0 ].FRect.x;
    InfoRect[ 0 ].FRect.h := 236 - InfoRect[ 0 ].FRect.y;
    InfoRect[ 0 ].FInfo := GameFont.DrawText( TextMessage[ 32 ], InfoPanel.w, InfoPanel.h );
     //Primary->Stealth
    for i := 1 to 9 do
    begin
      InfoRect[ i ].FRect.x := 289;
      InfoRect[ i ].FRect.w := 457 - InfoRect[ i ].FRect.x;
      InfoRect[ i ].FRect.y := 239 + ( i - 2 ) * LineHeight;
      InfoRect[ i ].FRect.h := ( 239 + ( i - 2 ) * LineHeight + LineHeight ) - InfoRect[ i ].FRect.y;
    end;
    InfoRect[ 1 ].FRect.x := 0; //no longer used here
    InfoRect[ 1 ].FRect.w := 0;
    InfoRect[ 1 ].FInfo := nil; //Primary skills are your characters main traits.  These skills determine '+
                       //'your Secondary skills, Resistance modifiers and Damage modifers.  Training '+
                       //'points are used to increase your Primary skills.';
    InfoRect[ 2 ].FInfo := GameFont.DrawText( TextMessage[ 33 ], InfoPanel.w, InfoPanel.h ) ; //'Strength represents the physical strength of a character.  Strength affects '+
                       //'how much damage a character inflicts in battle.';
    InfoRect[ 3 ].FInfo := GameFont.DrawText( TextMessage[ 34 ], InfoPanel.w, InfoPanel.h ); //'Coordination represents how agile a character is.  Coordination affects '+
                       //'a character''s movement, recovery and resistance modifiers.';
    InfoRect[ 4 ].FInfo := GameFont.DrawText( TextMessage[ 35 ], InfoPanel.w, InfoPanel.h ); //'Constitution represents a characters physical hardiness.  Constitution affects '+
                       //'a character''s healing rate and hit points.';
    InfoRect[ 5 ].FInfo := GameFont.DrawText( TextMessage[ 36 ], InfoPanel.w, InfoPanel.h ); //'Perception represents how well a character senses the area around him.';
                       //'Perception affects a character''s...something.  Lord knows I''m stumped.';
    InfoRect[ 6 ].FInfo := GameFont.DrawText( TextMessage[ 37 ], InfoPanel.w, InfoPanel.h ); //'Charm represents a character''s personal magnetism.  Charm affects the '+
                       //'prices a character can command when buying or selling items.';
    InfoRect[ 7 ].FInfo := GameFont.DrawText( TextMessage[ 38 ], InfoPanel.w, InfoPanel.h ); //'Mysticism represents a character''s magical ability.  Mysticism affects '+
                       //'the character''s recharge rate and mana.';
    InfoRect[ 8 ].FInfo := GameFont.DrawText( TextMessage[ 39 ], InfoPanel.w, InfoPanel.h ); //'Combat represents a character''s fighting ability.  Combat affects '+
                       //'the character''s damage modifiers.';
    InfoRect[ 9 ].FInfo := GameFont.DrawText( TextMessage[ 40 ], InfoPanel.w, InfoPanel.h ); //'Stealth represents the character''s ability to move and avoid detection.';


    i := 10;
     //the characters name
    InfoRect[ i ].FRect.x := 301;
    InfoRect[ i ].FRect.y := 92;
    InfoRect[ i ].FRect.w := 448 - InfoRect[ i ].FRect.x;
    InfoRect[ i ].FRect.h := 120 - InfoRect[ i ].FRect.y;
    InfoRect[ i ].FInfo := GameFont.DrawText( TextMessage[ 41 ], InfoPanel.w, InfoPanel.h );
     //the appearance
    inc( i );
    InfoRect[ i ].FRect.x := 113;
    InfoRect[ i ].FRect.y := 92;
    InfoRect[ i ].FRect.w := 281 - InfoRect[ i ].FRect.x;
    InfoRect[ i ].FRect.h := 221 - InfoRect[ i ].FRect.y;
    InfoRect[ i ].FInfo := GameFont.DrawText( TextMessage[ 42 ], InfoPanel.w, InfoPanel.h );
     //shirt color
    inc( i );
    InfoRect[ i ].FRect.x := 113;
    InfoRect[ i ].FRect.y := 236;
    InfoRect[ i ].FRect.w := 281 - InfoRect[ i ].FRect.x;
    InfoRect[ i ].FRect.h := 264 - InfoRect[ i ].FRect.y;
    InfoRect[ i ].FInfo := GameFont.DrawText( TextMessage[ 43 ], InfoPanel.w, InfoPanel.h );
     //pants
    inc( i );
    InfoRect[ i ].FRect.x := 113;
    InfoRect[ i ].FRect.y := 278;
    InfoRect[ i ].FRect.w := 281 - InfoRect[ i ].FRect.x;
    InfoRect[ i ].FRect.h := 306 - InfoRect[ i ].FRect.y;
    InfoRect[ i ].FInfo := GameFont.DrawText( TextMessage[ 44 ], InfoPanel.w, InfoPanel.h );
     //hair color
    inc( i );
    InfoRect[ i ].FRect.x := 113;
    InfoRect[ i ].FRect.y := 321;
    InfoRect[ i ].FRect.w := 281 - InfoRect[ i ].FRect.x;
    InfoRect[ i ].FRect.h := 348 - InfoRect[ i ].FRect.y;
    InfoRect[ i ].FInfo := GameFont.DrawText( TextMessage[ 45 ], InfoPanel.w, InfoPanel.h );
     //hair style
    inc( i );
    InfoRect[ i ].FRect.x := 113;
    InfoRect[ i ].FRect.y := 363;
    InfoRect[ i ].FRect.w := 281 - InfoRect[ i ].FRect.x;
    InfoRect[ i ].FRect.h := 391 - InfoRect[ i ].FRect.y;
    InfoRect[ i ].FInfo := GameFont.DrawText( TextMessage[ 46 ], InfoPanel.w, InfoPanel.h );
     //beard
    inc( i );
    InfoRect[ i ].FRect.x := 113;
    InfoRect[ i ].FRect.y := 406;
    InfoRect[ i ].FRect.w := 281 - InfoRect[ i ].FRect.x;
    InfoRect[ i ].FRect.h := 434 - InfoRect[ i ].FRect.y;
    InfoRect[ i ].FInfo := GameFont.DrawText( TextMessage[ 47 ], InfoPanel.w, InfoPanel.h );
    inc( i );
    InfoRect[ i ].FRect.x := 300;
    InfoRect[ i ].FRect.y := 132;
    InfoRect[ i ].FRect.w := 468 - InfoRect[ i ].FRect.x;
    InfoRect[ i ].FRect.h := 160 - InfoRect[ i ].FRect.y;
    InfoRect[ i ].FInfo := GameFont.DrawText( TextMessage[ 48 ], InfoPanel.w, InfoPanel.h ); //  Fighting training places an emphasis on your '+
                       //'character''s combat ability, Scouting emphasizes your character''s stealth talents '+
                       //'and Magic emphasizes your character''s spellcasting ability.';

    //now for the selectable text
    //Shirt color
    i := 0;
    SelectRect[ i ].FInfo := GameFont.DrawText( TextMessage[ 49 ], InfoPanel.w, InfoPanel.h );
    SelectRect[ i ].FText := GameFont.DrawText( TextMessage[ 70 ] );
    SelectRect[ i ].FRect.x := 293;
    SelectRect[ i ].FRect.y := 265;
    SelectRect[ i ].FRect.w := 96;
    SelectRect[ i ].FRect.h := 21;
    inc( i );
    SelectRect[ i ].FInfo := GameFont.DrawText( TextMessage[ 50 ], InfoPanel.w, InfoPanel.h );
    SelectRect[ i ].FText := GameFont.DrawText( TextMessage[ 71 ] );
    SelectRect[ i ].FRect.x := SelectRect[ i - 1 ].FRect.x;
    SelectRect[ i ].FRect.y := SelectRect[ i - 1 ].FRect.y + SelectRect[ i - 1 ].FRect.h;
    SelectRect[ i ].FRect.w := 96;
    SelectRect[ i ].FRect.h := 21;
    inc( i );
    SelectRect[ i ].FInfo := GameFont.DrawText( TextMessage[ 51 ], InfoPanel.w, InfoPanel.h );
    SelectRect[ i ].FText := GameFont.DrawText( TextMessage[ 72 ] );
    SelectRect[ i ].FRect.x := SelectRect[ i - 1 ].FRect.x;
    SelectRect[ i ].FRect.y := SelectRect[ i - 1 ].FRect.y + SelectRect[ i - 1 ].FRect.h;
    SelectRect[ i ].FRect.w := 96;
    SelectRect[ i ].FRect.h := 21;
    inc( i );
    SelectRect[ i ].FInfo := GameFont.DrawText( TextMessage[ 52 ], InfoPanel.w, InfoPanel.h );
    SelectRect[ i ].FText := GameFont.DrawText( TextMessage[ 73 ] );
    SelectRect[ i ].FRect.x := SelectRect[ i - 1 ].FRect.x;
    SelectRect[ i ].FRect.y := SelectRect[ i - 1 ].FRect.y + SelectRect[ i - 1 ].FRect.h;
    SelectRect[ i ].FRect.w := 96;
    SelectRect[ i ].FRect.h := 21;
     //Pants color
    inc( i );
    SelectRect[ i ].FInfo := GameFont.DrawText( TextMessage[ 53 ], InfoPanel.w, InfoPanel.h );
    SelectRect[ i ].FText := GameFont.DrawText( TextMessage[ 70 ] );
    SelectRect[ i ].FRect.x := SelectRect[ i - 1 ].FRect.x;
    SelectRect[ i ].FRect.y := 307;
    SelectRect[ i ].FRect.w := 96;
    SelectRect[ i ].FRect.h := 21;
    inc( i );
    SelectRect[ i ].FInfo := GameFont.DrawText( TextMessage[ 54 ], InfoPanel.w, InfoPanel.h );
    SelectRect[ i ].FText := GameFont.DrawText( TextMessage[ 71 ] );
    SelectRect[ i ].FRect.x := SelectRect[ i - 1 ].FRect.x;
    SelectRect[ i ].FRect.y := SelectRect[ i - 1 ].FRect.y + SelectRect[ i - 1 ].FRect.h;
    SelectRect[ i ].FRect.w := 96;
    SelectRect[ i ].FRect.h := 21;
    inc( i );
    SelectRect[ i ].FInfo := GameFont.DrawText( TextMessage[ 55 ], InfoPanel.w, InfoPanel.h );
    SelectRect[ i ].FText := GameFont.DrawText( TextMessage[ 72 ] );
    SelectRect[ i ].FRect.x := SelectRect[ i - 1 ].FRect.x;
    SelectRect[ i ].FRect.y := SelectRect[ i - 1 ].FRect.y + SelectRect[ i - 1 ].FRect.h;
    SelectRect[ i ].FRect.w := 96;
    SelectRect[ i ].FRect.h := 21;
    inc( i );
    SelectRect[ i ].FInfo := GameFont.DrawText( TextMessage[ 56 ], InfoPanel.w, InfoPanel.h );
    SelectRect[ i ].FText := GameFont.DrawText( TextMessage[ 73 ] );
    SelectRect[ i ].FRect.x := SelectRect[ i - 1 ].FRect.x;
    SelectRect[ i ].FRect.y := SelectRect[ i - 1 ].FRect.y + SelectRect[ i - 1 ].FRect.h;
    SelectRect[ i ].FRect.w := 96;
    SelectRect[ i ].FRect.h := 21;
     //hair color
    inc( i );
    SelectRect[ i ].FInfo := GameFont.DrawText( TextMessage[ 57 ], InfoPanel.w, InfoPanel.h );
    SelectRect[ i ].FText := GameFont.DrawText( TextMessage[ 74 ] );
    SelectRect[ i ].FRect.x := SelectRect[ i - 1 ].FRect.x;
    SelectRect[ i ].FRect.y := 350;
    SelectRect[ i ].FRect.w := 96;
    SelectRect[ i ].FRect.h := 21;
    inc( i );
    SelectRect[ i ].FInfo := GameFont.DrawText( TextMessage[ 58 ], InfoPanel.w, InfoPanel.h );
    SelectRect[ i ].FText := GameFont.DrawText( TextMessage[ 71 ] );
    SelectRect[ i ].FRect.x := SelectRect[ i - 1 ].FRect.x;
    SelectRect[ i ].FRect.y := SelectRect[ i - 1 ].FRect.y + SelectRect[ i - 1 ].FRect.h;
    SelectRect[ i ].FRect.w := 96;
    SelectRect[ i ].FRect.h := 21;
    inc( i );
    SelectRect[ i ].FInfo := GameFont.DrawText( TextMessage[ 59 ], InfoPanel.w, InfoPanel.h );
    SelectRect[ i ].FText := GameFont.DrawText( TextMessage[ 75 ] );
    SelectRect[ i ].FRect.x := SelectRect[ i - 1 ].FRect.x;
    SelectRect[ i ].FRect.y := SelectRect[ i - 1 ].FRect.y + SelectRect[ i - 1 ].FRect.h;
    SelectRect[ i ].FRect.w := 96;
    SelectRect[ i ].FRect.h := 21;
    inc( i );
    SelectRect[ i ].FInfo := GameFont.DrawText( TextMessage[ 60 ], InfoPanel.w, InfoPanel.h );
    SelectRect[ i ].FText := GameFont.DrawText( TextMessage[ 76 ] );
    SelectRect[ i ].FRect.x := SelectRect[ i - 1 ].FRect.x;
    SelectRect[ i ].FRect.y := SelectRect[ i - 1 ].FRect.y + SelectRect[ i - 1 ].FRect.h;
    SelectRect[ i ].FRect.w := 96;
    SelectRect[ i ].FRect.h := 21;
     //Hair style
    inc( i );
    SelectRect[ i ].FInfo := GameFont.DrawText( TextMessage[ 61 ], InfoPanel.w, InfoPanel.h );
    SelectRect[ i ].FText := GameFont.DrawText( TextMessage[ 77 ] );
    SelectRect[ i ].FRect.x := SelectRect[ i - 1 ].FRect.x;
    SelectRect[ i ].FRect.y := 393;
    SelectRect[ i ].FRect.w := 96;
    SelectRect[ i ].FRect.h := 21;
    inc( i );
    SelectRect[ i ].FInfo := GameFont.DrawText( TextMessage[ 62 ], InfoPanel.w, InfoPanel.h );
    SelectRect[ i ].FText := GameFont.DrawText( TextMessage[ 78 ] );
    SelectRect[ i ].FRect.x := SelectRect[ i - 1 ].FRect.x;
    SelectRect[ i ].FRect.y := SelectRect[ i - 1 ].FRect.y + SelectRect[ i - 1 ].FRect.h;
    SelectRect[ i ].FRect.w := 96;
    SelectRect[ i ].FRect.h := 21;
    inc( i );
    SelectRect[ i ].FInfo := GameFont.DrawText( TextMessage[ 63 ], InfoPanel.w, InfoPanel.h );
    SelectRect[ i ].FText := GameFont.DrawText( TextMessage[ 79 ] );
    SelectRect[ i ].FRect.x := SelectRect[ i - 1 ].FRect.x;
    SelectRect[ i ].FRect.y := SelectRect[ i - 1 ].FRect.y + SelectRect[ i - 1 ].FRect.h;
    SelectRect[ i ].FRect.w := 96;
    SelectRect[ i ].FRect.h := 21;
    inc( i );
    SelectRect[ i ].FInfo := GameFont.DrawText( TextMessage[ 64 ], InfoPanel.w, InfoPanel.h );
    SelectRect[ i ].FText := GameFont.DrawText( TextMessage[ 80 ] );
    SelectRect[ i ].FRect.x := SelectRect[ i - 1 ].FRect.x;
    SelectRect[ i ].FRect.y := SelectRect[ i - 1 ].FRect.y + SelectRect[ i - 1 ].FRect.h;
    SelectRect[ i ].FRect.w := 96;
    SelectRect[ i ].FRect.h := 21;
     //beard
    inc( i );
    SelectRect[ i ].FInfo := GameFont.DrawText( TextMessage[ 65 ], InfoPanel.w, InfoPanel.h );
    SelectRect[ i ].FText := GameFont.DrawText( TextMessage[ 81 ] );
    SelectRect[ i ].FRect.x := SelectRect[ i - 1 ].FRect.x;
    SelectRect[ i ].FRect.y := 436;
    SelectRect[ i ].FRect.w := 96;
    SelectRect[ i ].FRect.h := 21;
    inc( i );
    SelectRect[ i ].FInfo := GameFont.DrawText( TextMessage[ 66 ], InfoPanel.w, InfoPanel.h );
    SelectRect[ i ].FText := GameFont.DrawText( TextMessage[ 82 ] );
    SelectRect[ i ].FRect.x := SelectRect[ i - 1 ].FRect.x;
    SelectRect[ i ].FRect.y := SelectRect[ i - 1 ].FRect.y + SelectRect[ i - 1 ].FRect.h;
    SelectRect[ i ].FRect.w := 96;
    SelectRect[ i ].FRect.h := 21;

    //Training
    inc( i );
    SelectRect[ i ].FInfo := GameFont.DrawText( TextMessage[ 67 ], InfoPanel.w, InfoPanel.h - 20 );
    SelectRect[ i ].FText := GameFont.DrawText( TextMessage[ 83 ] );
    SelectRect[ i ].FRect.x := 480;
    SelectRect[ i ].FRect.y := 27;
    SelectRect[ i ].FRect.w := 96;
    SelectRect[ i ].FRect.h := 21;
    inc( i );
    SelectRect[ i ].FInfo := GameFont.DrawText( TextMessage[ 68 ], InfoPanel.w, InfoPanel.h - 20 );
    SelectRect[ i ].FText := GameFont.DrawText( TextMessage[ 84 ] );
    SelectRect[ i ].FRect.x := SelectRect[ i - 1 ].FRect.x;
    SelectRect[ i ].FRect.y := SelectRect[ i - 1 ].FRect.y + SelectRect[ i - 1 ].FRect.h;
    SelectRect[ i ].FRect.w := 96;
    SelectRect[ i ].FRect.h := 21;
    inc( i );
    SelectRect[ i ].FInfo := GameFont.DrawText( TextMessage[ 69 ], InfoPanel.w, InfoPanel.h - 20 );
    SelectRect[ i ].FText := GameFont.DrawText( TextMessage[ 85 ] );
    SelectRect[ i ].FRect.x := SelectRect[ i - 1 ].FRect.x;
    SelectRect[ i ].FRect.y := SelectRect[ i - 1 ].FRect.y + SelectRect[ i - 1 ].FRect.h;
    SelectRect[ i ].FRect.w := 96;
    SelectRect[ i ].FRect.h := 21;

    // Set up the Statistic Rectangles
    i := 0;
    StatRect[ i ].FRect.x := 431;
    StatRect[ i ].FRect.y := 211;
    StatRect[ i ].FRect.w := 20;
    StatRect[ i ].FRect.h := 24;
    StatRect[ i ].FInfo := GameFont.DrawText( IntToStr( Player.TrainingPoints ) );
    inc( i );
    StatRect[ i ].FRect.x := 431;
    StatRect[ i ].FRect.y := ArrowRect[ i - 1 ].FRect.y - 2;
    StatRect[ i ].FRect.w := 20;
    StatRect[ i ].FRect.h := 24;
    StatRect[ i ].FInfo := GameFont.DrawText( IntToStr( Player.Strength ) );
    inc( i );
    StatRect[ i ].FRect.x := 431;
    StatRect[ i ].FRect.y := ArrowRect[ i - 1 ].FRect.y - 2;
    StatRect[ i ].FRect.w := 20;
    StatRect[ i ].FRect.h := 24;
    StatRect[ i ].FInfo := GameFont.DrawText( IntToStr( Player.Coordination ) );
    inc( i );
    StatRect[ i ].FRect.x := 431;
    StatRect[ i ].FRect.y := ArrowRect[ i - 1 ].FRect.y - 2;
    StatRect[ i ].FRect.w := 20;
    StatRect[ i ].FRect.h := 24;
    StatRect[ i ].FInfo := GameFont.DrawText( IntToStr( Player.Constitution ) );
    inc( i );
    StatRect[ i ].FRect.x := 431;
    StatRect[ i ].FRect.y := ArrowRect[ i - 1 ].FRect.y - 2;
    StatRect[ i ].FRect.w := 20;
    StatRect[ i ].FRect.h := 24;
    StatRect[ i ].FInfo := GameFont.DrawText( IntToStr( Player.Perception ) );
    inc( i );
    StatRect[ i ].FRect.x := 431;
    StatRect[ i ].FRect.y := ArrowRect[ i - 1 ].FRect.y - 2;
    StatRect[ i ].FRect.w := 20;
    StatRect[ i ].FRect.h := 24;
    StatRect[ i ].FInfo := GameFont.DrawText( IntToStr( Player.Charm ) );
    inc( i );
    StatRect[ i ].FRect.x := 431;
    StatRect[ i ].FRect.y := ArrowRect[ i - 1 ].FRect.y - 2;
    StatRect[ i ].FRect.w := 20;
    StatRect[ i ].FRect.h := 24;
    StatRect[ i ].FInfo := GameFont.DrawText( IntToStr( Player.Mysticism ) );
    inc( i );
    StatRect[ i ].FRect.x := 431;
    StatRect[ i ].FRect.y := ArrowRect[ i - 1 ].FRect.y - 2;
    StatRect[ i ].FRect.w := 20;
    StatRect[ i ].FRect.h := 24;
    StatRect[ i ].FInfo := GameFont.DrawText( IntToStr( Player.Combat ) );
    inc( i );
    StatRect[ i ].FRect.x := 431;
    StatRect[ i ].FRect.y := ArrowRect[ i - 1 ].FRect.y - 2;
    StatRect[ i ].FRect.w := 20;
    StatRect[ i ].FRect.h := 24;
    StatRect[ i ].FInfo := GameFont.DrawText( IntToStr( Player.Stealth ) );
  except
    on E: Exception do
      Log.LogError( E.Message, FailName );
  end;
end;

procedure TNewGame.FreeSurfaces;
var
  i : integer;
begin
  SDL_FreeSurface( DXSelectRect ); //circle used for outline
  SDL_FreeSurface( DXBlack );
  SDL_FreeSurface( DXContinue );
  SDL_FreeSurface( DXCancel );
  SDL_FreeSurface( DXLeftArrow );
  SDL_FreeSurface( DXRightArrow );
  SDL_FreeSurface( DXPickList );
  SDL_FreeSurface( DXPlayerName );

  for i := Low( InfoRect ) to High( InfoRect ) do
    if InfoRect[ i ].FInfo <> nil then
      SDL_FreeSurface( InfoRect[ i ].FInfo );

  for i := Low( ArrowRect ) to High( ArrowRect ) do
    if ArrowRect[ i ].FInfo <> nil then
      SDL_FreeSurface( ArrowRect[ i ].FInfo );

  for i := Low( SelectRect ) to High( SelectRect ) do
  begin
    if SelectRect[ i ].FInfo <> nil then
      SDL_FreeSurface( SelectRect[ i ].FInfo );
    if SelectRect[ i ].FText <> nil then
      SDL_FreeSurface( SelectRect[ i ].FText );
  end;

  for i := Low( DXTextMessage ) to High( DXTextMessage ) do
  begin
    if DXTextMessage[ i ] <> nil then
      SDL_FreeSurface( DXTextMessage[ i ] );
  end;

  for i := Low( StatRect ) to High( StatRect ) do
  begin
    if StatRect[ i ].FInfo <> nil then
      SDL_FreeSurface( StatRect[ i ].FInfo );
  end;

  ExText.Close;

  inherited;
end;

procedure TNewGame.KeyDown( var Key : TSDLKey; Shift : TSDLMod; unicode : UInt16 );
const
  FailName : string = 'TNewGame.KeyDown';
begin
  inherited;
  try
    case RenderMode of
      rmNormal :
      begin
        case Key of
          SDLK_RETURN :
            begin
              NextGameInterface := TMainMenu;
              MainWindow.Rendering := false;
            end;

          SDLK_ESCAPE :
            begin
              NextGameInterface := TMainMenu;
              MainWindow.Rendering := false;
            end;
        end;
      end;

      rmPickList :
      begin
        case Key of
          SDLK_RETURN :
            begin
              RenderMode := rmNormal;
            end;

          SDLK_ESCAPE :
            begin
              RenderMode := rmNormal;
            end;

          SDLK_UP :
          begin

          end;

          SDLK_DOWN :
          begin
            
          end;
        end;
      end;
    end;
  except
    on E: Exception do
      Log.LogError( E.Message, FailName );
  end;
end;

procedure TNewGame.LoadBaseValues;
const
  FailName : string = 'TNewGame.LoadBaseValues';
{var
  i : integer; }
begin
  try
    if Player <> nil then
      Player.Free;

    Player := TCharacter.Create;
    Player.TrainingPoints := 20;

    //we store thse values so that we can keep the player from lowering his score beyond its start
    {Damage := Player.Damage;
    Resistance := Player.Resistance;
    BaseStrength := Player.BaseStrength;
    BaseCoordination := Player.BaseCoordination;
    BaseConstitution := Player.BaseConstitution;
    BasePerception := Player.BasePerception;
    BaseCharm := Player.BaseCharm;
    BaseMysticism := Player.BaseMysticism;
    BaseCombat := Player.BaseCombat;
    BaseStealth := Player.BaseStealth;
    TrainingPoints := Player.TrainingPoints;}

    {for i := 0 to 7 do
    begin //initialize adjustments to zero
      StatAdjustments[ i ] := 0;
    end;}

    // Set Default Appearance
    ixSelectedShirt := 0;
    ixSelectedPants := 4;
    ixSelectedHair := 8;
    ixSelectedHairStyle := 12;
    ixSelectedBeard := 17;
    ixSelectedTraining := 18;

    Player.Strength := Player.BaseStrength + 5;
    Player.Coordination := Player.BaseCoordination + 2;
    Player.Constitution := Player.BaseConstitution + 3;
    Player.Perception := Player.BasePerception - 3;
    Player.Charm := Player.BaseCharm - 3;
    Player.Mysticism := Player.BaseMysticism - 3;
    Player.Combat := Player.BaseCombat + 10;
    Player.Stealth := Player.BaseStealth + 0;
  except
    on E: Exception do
      Log.LogError( E.Message, FailName );
  end;
end;

procedure TNewGame.LoadNames;
const
  FailName : string = 'TNewGame.LoadNames';
begin
  try
    StatName[ 0 ][ 1 ] := TextMessage[ 86 ]; //'Strength';
    StatName[ 0 ][ 2 ] := TextMessage[ 87 ]; //'Coordination';
    StatName[ 0 ][ 3 ] := TextMessage[ 88 ]; //'Constitution';
    StatName[ 0 ][ 4 ] := TextMessage[ 89 ]; //'Perception';
    StatName[ 0 ][ 5 ] := TextMessage[ 90 ]; //'Charm';
    StatName[ 0 ][ 6 ] := TextMessage[ 91 ]; //'Mysticism';
    StatName[ 0 ][ 7 ] := TextMessage[ 92 ]; //'Combat';
    StatName[ 0 ][ 8 ] := TextMessage[ 93 ]; //'Stealth';

    StatName[ 1 ][ 1 ] := TextMessage[ 94 ]; //'Piercing';
    StatName[ 1 ][ 2 ] := TextMessage[ 95 ]; //'Crushing';
    StatName[ 1 ][ 3 ] := TextMessage[ 96 ]; //'Cutting';
    StatName[ 1 ][ 4 ] := TextMessage[ 97 ]; //'Heat';
    StatName[ 1 ][ 5 ] := TextMessage[ 98 ]; //'Cold';
    StatName[ 1 ][ 6 ] := TextMessage[ 99 ]; //'Electric';
    StatName[ 1 ][ 7 ] := TextMessage[ 100 ]; //'Poison';
    StatName[ 1 ][ 8 ] := TextMessage[ 101 ]; //'Magic';
    StatName[ 1 ][ 9 ] := TextMessage[ 102 ]; //'Mental';
    StatName[ 1 ][ 10 ] := TextMessage[ 103 ]; //'Stun';
    StatName[ 1 ][ 11 ] := TextMessage[ 104 ]; //'Special';
  except
    on E: Exception do
      Log.LogError( E.Message, FailName );
  end;
end;

procedure TNewGame.LoadSurfaces;
const
  FailName : string = 'TNewGame.LoadSurfaces';
  Flags : Cardinal = SDL_SRCCOLORKEY or SDL_RLEACCEL or SDL_HWACCEL;
var
  i : integer;
  C : TSDL_Color;
begin
  inherited;
  try
    C.r := 231;
    C.g := 156;
    C.b := 0;
    GameFont.ForeGroundColour := C;
    C.r := 0;
    C.g := 0;
    C.b := 0;
    GameFont.BackGroundColour := C;
    {if SoASettings.UseSmallFont then
      GameFont.FontSize := 13
    else}
      GameFont.FontSize := 18;

    ExText.Open( 'CharCreation' );
    for i := Low( TextMessage ) to High( TextMessage ) do
    begin
      TextMessage[ i ] := ExText.GetText( 'Message' + IntToStr( i ) );
    end;

    for i := Low( DXTextMessage ) to High( DXTextMessage ) do
    begin
      if i > 7 then
        DXTextMessage[ i ] := GameFont.DrawText( TextMessage[ i ], 190, 274 )
      else
        DXTextMessage[ i ] := GameFont.DrawText( TextMessage[ i ] );
    end;

    DXBack := SDL_LoadBMP( PChar( SoASettings.InterfacePath + DIR_SEP + SoASettings.LanguagePath + DIR_SEP + 'charcreate.bmp' ) );
    SDL_SetColorKey( DXBack, Flags, SDL_MapRGB( DXBack.format, 0, 255, 255 ) );

    DXSelectRect := SDL_LoadBMP( PChar( SoASettings.InterfacePath + DIR_SEP + 'chaRedoval.bmp' ) );
    SDL_SetColorKey( DXSelectRect, Flags, SDL_MapRGB( DXSelectRect.format, 0, 255, 255 ) );

    DXBlack := SDL_LoadBMP( PChar( SoASettings.InterfacePath + DIR_SEP + 'chaBlack.bmp' ) );
    SDL_SetColorKey( DXBlack, Flags, SDL_MapRGB( DXBlack.format, 0, 255, 255 ) );

    DXContinue := SDL_LoadBMP( PChar( SoASettings.InterfacePath + DIR_SEP + SoASettings.LanguagePath + DIR_SEP + 'chaContinue.bmp' ) );
    SDL_SetColorKey( DXContinue, Flags, SDL_MapRGB( DXContinue.format, 255, 255, 255 ) );

    DXCancel := SDL_LoadBMP( PChar( SoASettings.InterfacePath + DIR_SEP + SoASettings.LanguagePath + DIR_SEP + 'chaCancel.bmp' ) );
    SDL_SetColorKey( DXCancel, Flags, SDL_MapRGB( DXCancel.format, 0, 255, 255 ) );

    DXLeftArrow := SDL_LoadBMP( PChar( SoASettings.InterfacePath + DIR_SEP + 'leftarrow.bmp' ) );
    SDL_SetColorKey( DXLeftArrow, Flags, SDL_MapRGB( DXLeftArrow.format, 0, 255, 255  ) );

    DXRightArrow := SDL_LoadBMP( PChar( SoASettings.InterfacePath + DIR_SEP + 'rightarrow.bmp' ) );
    SDL_SetColorKey( DXRightArrow, Flags, SDL_MapRGB( DXRightArrow.format, 0, 255, 255 ) );

    DXPickList := SDL_LoadBMP( PChar( SoASettings.InterfacePath + DIR_SEP + SoASettings.LanguagePath + DIR_SEP + 'chaChooseBox.bmp' ) );
    SDL_SetColorKey( DXPickList, Flags, SDL_MapRGB( DXBack.format, 0, 255, 255 ) );

    ContinueRect.x := 400;
    ContinueRect.y := 449;
    ContinueRect.w := DXContinue.w;
    ContinueRect.h := DXContinue.h;

    CancelRect.x := 100;
    CancelRect.y := 449;
    CancelRect.w := DXCancel.w;
    CancelRect.h := DXCancel.h;

    LeftArrowRect.x := 112;
    LeftArrowRect.y := 73;
    LeftArrowRect.w := DXLeftArrow.w;
    LeftArrowRect.h := DXLeftArrow.h;

    RightArrowRect.x := 250;
    RightArrowRect.y := 73;
    RightArrowRect.w := DXRightArrow.w;
    RightArrowRect.h := DXRightArrow.h;

    InfoPanel.x := 488;
    InfoPanel.y := 160;
    InfoPanel.w := 194;
    InfoPanel.h := 274;

    OKRect.x := 37;
    OKRect.y := 144;
    OKRect.w := 44;
    OKRect.h := 28;

    LoadNames;
    LoadBaseValues;
    CreateCollisionRects;
    //ShowStats;
    //DrawTheGuy;

    RenderMode := rmNormal;
  except
    on E: Exception do
      Log.LogError( E.Message, FailName );
  end;
end;

procedure TNewGame.MouseDown( Button : Integer; Shift : TSDLMod; CurrentPos : TPoint );
const
  FailName : string = 'TNewGame.MouseDown';
var
  x, StatAdjustment : integer;
  CharacterName : string;
begin
  inherited;
  try
    case RenderMode of
      rmNormal :
      begin
        MouseOverOptions := moNone;
        if PointIsInRect( CurrentPos, ContinueRect.x, ContinueRect.y, ContinueRect.x + ContinueRect.w, ContinueRect.y + ContinueRect.h )
        and ( Player.Name <> '' )
        and ( Player.TrainingPoints = 0 ) then
        begin
          // Check to see we have all data before starting the new game
          NextGameInterface := TMainMenu;
          MainWindow.Rendering := false;
        end
        else if PointIsInRect( CurrentPos, CancelRect.x, CancelRect.y, CancelRect.x + CancelRect.w, CancelRect.y + CancelRect.h ) then
        begin
          NextGameInterface := TMainMenu;
          MainWindow.Rendering := false;
        end
        else if PointIsInRect( CurrentPos, LeftArrowRect.x, LeftArrowRect.y, LeftArrowRect.x + LeftArrowRect.w, LeftArrowRect.y + LeftArrowRect.h ) then
          MouseOverOptions := moLeftArrow
        else if PointIsInRect( CurrentPos, RightArrowRect.x, RightArrowRect.y, RightArrowRect.x + RightArrowRect.w, RightArrowRect.y + RightArrowRect.h ) then
          MouseOverOptions := moRightArrow
        else
        begin
          for x := Low( ArrowRect ) to High( ArrowRect ) do
          begin
            if PointIsInRect( CurrentPos, ArrowRect[ x ].FRect.x, ArrowRect[ x ].FRect.y, ArrowRect[ x ].FRect.x + ArrowRect[ x ].FRect.w, ArrowRect[ x ].FRect.y + ArrowRect[ x ].FRect.h ) then
            begin
              MouseOverOptions := TMouseOverNewOptions( x + 18 );
              StatAdjustment := 0;
              case MouseOverOptions of
                moStrengthPlus..moCharmPlus :
                begin
                  StatAdjustment := -4;
                  if Player.TrainingPoints + StatAdjustment < 0 then
                    exit;
                  case MouseOverOptions of
                    moStrengthPlus :
                      Player.Strength := Player.Strength + 1;
                    moCoordinationPlus :
                      Player.Coordination := Player.Coordination + 1;
                    moConstitutionPlus :
                      Player.Constitution := Player.Constitution + 1;
                    moPerceptionPlus :
                      Player.Perception := Player.Perception + 1;
                    moCharmPlus :
                      Player.Charm := Player.Charm + 1;
                  end;
                end;

                moMysticismPlus..moStealthPlus :
                begin
                  StatAdjustment := -2;
                  if Player.TrainingPoints + StatAdjustment < 0 then
                    exit;
                  case MouseOverOptions of
                    moMysticismPlus :
                      Player.Mysticism := Player.Mysticism + 1;
                    moCombatPlus :
                      Player.Combat := Player.Combat + 1;
                    moStealthPlus :
                      Player.Stealth := Player.Stealth + 1;
                  end;
                end;

                moStrengthMinus..moCharmMinus :
                begin
                  StatAdjustment := +4;
                  if Player.TrainingPoints + StatAdjustment > 20 then
                    exit;
                  case MouseOverOptions of
                    moStrengthMinus :
                      Player.Strength := Player.Strength - 1;
                    moCoordinationMinus :
                      Player.Coordination := Player.Coordination - 1;
                    moConstitutionMinus :
                      Player.Constitution := Player.Constitution - 1;
                    moPerceptionMinus :
                      Player.Perception := Player.Perception - 1;
                    moCharmMinus :
                      Player.Charm := Player.Charm - 1;
                  end;
                end;

                moMysticismMinus..moStealthMinus :
                begin
                  StatAdjustment := +2;
                  if Player.TrainingPoints + StatAdjustment > 20 then
                    exit;
                  case MouseOverOptions of
                    moMysticismMinus :
                      Player.Mysticism := Player.Mysticism - 1;
                    moCombatMinus :
                      Player.Combat := Player.Combat - 1;
                    moStealthMinus :
                      Player.Stealth := Player.Stealth - 1;
                  end;
                end;
              end;
              Player.TrainingPoints := Player.TrainingPoints + StatAdjustment;
              ReCreateStats;
              exit;
            end;
          end;

          for x := Low( InfoRect ) to High( InfoRect ) do
          begin
            if PointIsInRect( CurrentPos, InfoRect[ x ].FRect.x, InfoRect[ x ].FRect.y, InfoRect[ x ].FRect.x + InfoRect[ x ].FRect.w, InfoRect[ x ].FRect.y + InfoRect[ x ].FRect.h ) then
            begin
              MouseOverOptions := TMouseOverNewOptions( x );
              case MouseOverOptions of
                moCharacterName :
                begin
                  CharacterName := Player.Name;
                  if DXPlayerName <> nil then
                    SDL_FreeSurface( DXPlayerName );
                  DXPlayerName := GameFont.Input( MainWindow.DisplaySurface, InfoRect[ Ord( moCharacterName ) ].FRect.x + 2, InfoRect[ Ord( moCharacterName ) ].FRect.y + 2, InfoRect[ Ord( moCharacterName ) ].FRect.w - 24, InfoRect[ Ord( moCharacterName ) ].FRect.h - 3, CharacterName );
                  Player.Name := CharacterName;
                end;

                moShirtColour :
                begin
                  RenderMode := rmPickList;
                  iPickListLow := 0;
                  iPickListHigh := 3;
                end;

                moPantsColour :
                begin
                  RenderMode := rmPickList;
                  iPickListLow := 4;
                  iPickListHigh := 7;
                end;

                moHairColour :
                begin
                  RenderMode := rmPickList;
                  iPickListLow := 8;
                  iPickListHigh := 11;
                end;

                moHairStyle :
                begin
                  RenderMode := rmPickList;
                  iPickListLow := 12;
                  iPickListHigh := 15;
                end;

                moBeard :
                begin
                  RenderMode := rmPickList;
                  iPickListLow := 16;
                  iPickListHigh := 17;
                end;

                moTrainingStyle :
                begin
                  RenderMode := rmPickList;
                  iPickListLow := 18;
                  iPickListHigh := 20;
                end;
              end;
              exit;
            end;
          end;
        end;
      end;

      rmPickList :
      begin
        case MouseOverOptions of
          moTrainingStyle :
          begin
            for x := iPickListLow to iPickListHigh do
            begin
              if PointIsInRect( CurrentPos, SelectRect[ x ].FRect.x, SelectRect[ x ].FRect.y, SelectRect[ x ].FRect.x + SelectRect[ x ].FRect.w, SelectRect[ x ].FRect.y + SelectRect[ x ].FRect.h ) then
              begin
                ixSelectedTraining := x;
                Player.TrainingPoints := 20;

                case ixSelectedTraining of
                  18 :
                  begin
                    Player.Strength := Player.BaseStrength + 5;
                    Player.Coordination := Player.BaseCoordination + 2;
                    Player.Constitution := Player.BaseConstitution + 3;
                    Player.Perception := Player.BasePerception - 3;
                    Player.Charm := Player.BaseCharm - 3;
                    Player.Mysticism := Player.BaseMysticism - 3;
                    Player.Combat := Player.BaseCombat + 10;
                    Player.Stealth := Player.BaseStealth + 0;
                  end;

                  19 :
                  begin
                    Player.Strength := Player.BaseStrength + 2;
                    Player.Coordination := Player.BaseCoordination + 5;
                    Player.Constitution := Player.BaseConstitution + 0;
                    Player.Perception := Player.BasePerception + 0;
                    Player.Charm := Player.BaseCharm - 3;
                    Player.Mysticism := Player.BaseMysticism - 3;
                    Player.Combat := Player.BaseCombat + 0;
                    Player.Stealth := Player.BaseStealth + 10;
                  end;

                  20 :
                  begin
                    Player.Strength := Player.BaseStrength + 0;
                    Player.Coordination := Player.BaseCoordination + 3;
                    Player.Constitution := Player.BaseConstitution + 2;
                    Player.Perception := Player.BasePerception + 2;
                    Player.Charm := Player.BaseCharm - 3;
                    Player.Mysticism := Player.BaseMysticism + 10;
                    Player.Combat := Player.BaseCombat + 0;
                    Player.Stealth := Player.BaseStealth - 3;
                  end;
                end;

                ReCreateStats;
                break;
              end;
            end;

            if PointIsInRect( CurrentPos, OKRect.x, OKRect.y, OKRect.x + OKRect.w, OKRect.y + OKRect.h ) then
              RenderMode := rmNormal;  
          end;
          
          moShirtColour :
          begin
            for x := iPickListLow to iPickListHigh do
            begin
              if PointIsInRect( CurrentPos, SelectRect[ x ].FRect.x, SelectRect[ x ].FRect.y, SelectRect[ x ].FRect.x + SelectRect[ x ].FRect.w, SelectRect[ x ].FRect.y + SelectRect[ x ].FRect.h ) then
              begin
                ixSelectedShirt := x;
                break;
              end;
            end;

            // Check if OK button hit
            if PointIsInRect( CurrentPos, OKRect.x, OKRect.y, OKRect.x + OKRect.w, OKRect.y + OKRect.h ) then
              RenderMode := rmNormal;
          end;

          moPantsColour :
          begin
            for x := iPickListLow to iPickListHigh do
            begin
              if PointIsInRect( CurrentPos, SelectRect[ x ].FRect.x, SelectRect[ x ].FRect.y, SelectRect[ x ].FRect.x + SelectRect[ x ].FRect.w, SelectRect[ x ].FRect.y + SelectRect[ x ].FRect.h ) then
              begin
                ixSelectedPants := x;
                break;
              end;
            end;

            // Check if OK button hit
            if PointIsInRect( CurrentPos, OKRect.x, OKRect.y, OKRect.x + OKRect.w, OKRect.y + OKRect.h ) then
              RenderMode := rmNormal;
          end;

          moHairColour :
          begin
            for x := iPickListLow to iPickListHigh do
            begin
              if PointIsInRect( CurrentPos, SelectRect[ x ].FRect.x, SelectRect[ x ].FRect.y, SelectRect[ x ].FRect.x + SelectRect[ x ].FRect.w, SelectRect[ x ].FRect.y + SelectRect[ x ].FRect.h ) then
              begin
                ixSelectedHair := x;
                break;
              end;
            end;

            // Check if OK button hit
            if PointIsInRect( CurrentPos, OKRect.x, OKRect.y, OKRect.x + OKRect.w, OKRect.y + OKRect.h ) then
              RenderMode := rmNormal;
          end;

          moHairStyle :
          begin
            for x := iPickListLow to iPickListHigh do
            begin
              if PointIsInRect( CurrentPos, SelectRect[ x ].FRect.x, SelectRect[ x ].FRect.y, SelectRect[ x ].FRect.x + SelectRect[ x ].FRect.w, SelectRect[ x ].FRect.y + SelectRect[ x ].FRect.h ) then
              begin
                ixSelectedHairStyle := x;
                break;
              end;
            end;

            // Check if OK button hit
            if PointIsInRect( CurrentPos, OKRect.x, OKRect.y, OKRect.x + OKRect.w, OKRect.y + OKRect.h ) then
              RenderMode := rmNormal;
          end;

          moBeard :
          begin
            for x := iPickListLow to iPickListHigh do
            begin
              if PointIsInRect( CurrentPos, SelectRect[ x ].FRect.x, SelectRect[ x ].FRect.y, SelectRect[ x ].FRect.x + SelectRect[ x ].FRect.w, SelectRect[ x ].FRect.y + SelectRect[ x ].FRect.h ) then
              begin
                ixSelectedBeard := x;
                break;
              end;
            end;

            // Check if OK button hit
            if PointIsInRect( CurrentPos, OKRect.x, OKRect.y, OKRect.x + OKRect.w, OKRect.y + OKRect.h ) then
              RenderMode := rmNormal;
          end;
        else
          RenderMode := rmNormal;
        end;
      end;
    end;
  except
    on E: Exception do
      Log.LogError( E.Message, FailName );
  end;
end;

procedure TNewGame.MouseMove( Shift : TSDLMod; CurrentPos, RelativePos : TPoint );
const
  FailName : string = 'TNewGame.MouseMove';
var
  x : integer;
begin
  inherited;
  try
    case RenderMode of
      rmNormal :
      begin
        MouseOverOptions := moNone;
        if PointIsInRect( CurrentPos, ContinueRect.x, ContinueRect.y, ContinueRect.x + ContinueRect.w, ContinueRect.y + ContinueRect.h ) then
          MouseOverOptions := moContinue
        else if PointIsInRect( CurrentPos, CancelRect.x, CancelRect.y, CancelRect.x + CancelRect.w, CancelRect.y + CancelRect.h ) then
          MouseOverOptions := moCancel
        else if PointIsInRect( CurrentPos, LeftArrowRect.x, LeftArrowRect.y, LeftArrowRect.x + LeftArrowRect.w, LeftArrowRect.y + LeftArrowRect.h ) then
          MouseOverOptions := moLeftArrow
        else if PointIsInRect( CurrentPos, RightArrowRect.x, RightArrowRect.y, RightArrowRect.x + RightArrowRect.w, RightArrowRect.y + RightArrowRect.h ) then
          MouseOverOptions := moRightArrow
        else
        begin
          for x := Low( ArrowRect ) to High( ArrowRect ) do
          begin
            if PointIsInRect( CurrentPos, ArrowRect[ x ].FRect.x, ArrowRect[ x ].FRect.y, ArrowRect[ x ].FRect.x + ArrowRect[ x ].FRect.w, ArrowRect[ x ].FRect.y + ArrowRect[ x ].FRect.h ) then
            begin
              MouseOverOptions := TMouseOverNewOptions( x + 18 );
              exit;
            end;
          end;

          for x := Low( InfoRect ) to High( InfoRect ) do
          begin
            if PointIsInRect( CurrentPos, InfoRect[ x ].FRect.x, InfoRect[ x ].FRect.y, InfoRect[ x ].FRect.x + InfoRect[ x ].FRect.w, InfoRect[ x ].FRect.y + InfoRect[ x ].FRect.h ) then
            begin
              MouseOverOptions := TMouseOverNewOptions( x );
              exit;
            end;
          end;
        end;
      end;

      rmPickList :
      begin
        moItem := -1;
        for x := iPickListLow to iPickListHigh do
        begin
          if PointIsInRect( CurrentPos, SelectRect[ x ].FRect.x, SelectRect[ x ].FRect.y, SelectRect[ x ].FRect.x + SelectRect[ x ].FRect.w, SelectRect[ x ].FRect.y + SelectRect[ x ].FRect.h ) then
          begin
            moItem := x;
            exit;
          end;
        end;
      end;
    end;
  except
    on E: Exception do
      Log.LogError( E.Message, FailName );
  end;
end;

procedure TNewGame.ReCreateStats;
begin
  if StatRect[ 0 ].FInfo <> nil then
    SDL_FreeSurface( StatRect[ 0 ].FInfo );
  StatRect[ 0 ].FInfo := GameFont.DrawText( IntToStr( Player.TrainingPoints ) );

  if StatRect[ 1 ].FInfo <> nil then
    SDL_FreeSurface( StatRect[ 1 ].FInfo );
  StatRect[ 1 ].FInfo := GameFont.DrawText( IntToStr( Player.Strength ) );

  if StatRect[ 2 ].FInfo <> nil then
    SDL_FreeSurface( StatRect[ 2 ].FInfo );
  StatRect[ 2 ].FInfo := GameFont.DrawText( IntToStr( Player.Coordination ) );

  if StatRect[ 3 ].FInfo <> nil then
    SDL_FreeSurface( StatRect[ 3 ].FInfo );
  StatRect[ 3 ].FInfo := GameFont.DrawText( IntToStr( Player.Constitution ) );

  if StatRect[ 4 ].FInfo <> nil then
    SDL_FreeSurface( StatRect[ 4 ].FInfo );
  StatRect[ 4 ].FInfo := GameFont.DrawText( IntToStr( Player.Perception ) );

  if StatRect[ 5 ].FInfo <> nil then
    SDL_FreeSurface( StatRect[ 5 ].FInfo );
  StatRect[ 5 ].FInfo := GameFont.DrawText( IntToStr( Player.Charm ) );

  if StatRect[ 6 ].FInfo <> nil then
    SDL_FreeSurface( StatRect[ 6 ].FInfo );
  StatRect[ 6 ].FInfo := GameFont.DrawText( IntToStr( Player.Mysticism ) );

  if StatRect[ 7 ].FInfo <> nil then
    SDL_FreeSurface( StatRect[ 7 ].FInfo );
  StatRect[ 7 ].FInfo := GameFont.DrawText( IntToStr( Player.Combat ) );

  if StatRect[ 8 ].FInfo <> nil then
    SDL_FreeSurface( StatRect[ 8 ].FInfo );
  StatRect[ 8 ].FInfo := GameFont.DrawText( IntToStr( Player.Stealth ) );
end;

procedure TNewGame.Render;
const
  FailName : string = 'TNewGame.Render';
var
  x : integer;
  lRect : TSDL_Rect;
begin
  inherited;
  try
    case RenderMode of
      rmNormal :
      begin
        case MouseOverOptions of
          moTrainingPoints..moTrainingStyle :
          begin
            SDL_BlitSurface( InfoRect[ Ord( MouseOverOptions ) ].FInfo, nil, MainWindow.DisplaySurface, @@InfoPanel );
          end;

          moContinue :
            begin
              if ( Player.Name <> '' )
              and ( Player.TrainingPoints = 0 ) then
                SDL_BlitSurface( DXContinue, nil, MainWindow.DisplaySurface, @@ContinueRect )
              else if ( Player.Name = '' ) then
                SDL_BlitSurface( DXTextMessage[ 8 ], nil, MainWindow.DisplaySurface, @@InfoPanel )
              else if ( Player.TrainingPoints <> 0 ) then
                SDL_BlitSurface( DXTextMessage[ 9 ], nil, MainWindow.DisplaySurface, @@InfoPanel );
            end;

          moCancel :
            begin
              SDL_BlitSurface( DXCancel, nil, MainWindow.DisplaySurface, @@CancelRect );
            end;

          moStrengthMinus..moStealthPlus :
            SDL_BlitSurface( ArrowRect[ Ord( MouseOverOptions ) - 18 ].FInfo, nil, MainWindow.DisplaySurface, @@InfoPanel );
        end;
      end;

      rmPickList :
      begin
        case MouseOverOptions of
          moShirtColour :
          begin
            lRect.x := 280;
            lRect.y := 239;
            lRect.w := DXPickList.w;
            lRect.h := DXPickList.h;
          end;

          moPantsColour :
          begin
            lRect.x := 280;
            lRect.y := 281;
            lRect.w := DXPickList.w;
            lRect.h := DXPickList.h;
          end;

          moHairColour :
          begin
            lRect.x := 280;
            lRect.y := 323;
            lRect.w := DXPickList.w;
            lRect.h := DXPickList.h;
          end;

          moHairStyle :
          begin
            lRect.x := 280;
            lRect.y := 365;
            lRect.w := DXPickList.w;
            lRect.h := DXPickList.h;
          end;

          moBeard :
          begin
            lRect.x := 280;
            lRect.y := 409;
            lRect.w := DXPickList.w;
            lRect.h := DXPickList.h;
          end;

          moTrainingStyle :
          begin
            lRect.x := 467;
            lRect.y := 0;
            lRect.w := DXPickList.w;
            lRect.h := DXPickList.h;
          end;
        else
          begin
            iPickListLow := 0;
            iPickListHigh := 3;
            lRect.x := 25;
            lRect.y := 25;
            lRect.w := DXPickList.w;
            lRect.h := DXPickList.h;
          end
        end;

        OKRect.x := lRect.x + 37;
        OKRect.y := lRect.y + 144;

        SDL_BlitSurface( DXPickList, nil, MainWindow.DisplaySurface, @@lRect );

        for x := iPickListLow to iPickListHigh do
        begin
          lRect := SelectRect[ x ].FRect;
          SDL_BlitSurface( SelectRect[ x ].FText, nil, MainWindow.DisplaySurface, @@lRect );
        end;

        if moItem > -1 then
        begin
          if moItem < 18 then
          begin
            lRect := InfoPanel;
          end
          else
          begin
            lRect := InfoPanel;
            lRect.y := 180;
          end;
          SDL_BlitSurface( SelectRect[ moItem ].FInfo, nil, MainWindow.DisplaySurface, @@lRect );
        end;
      end;
    end;

    lRect := InfoRect[ Ord( moShirtColour ) ].FRect;
    lRect.x := lRect.x + 2;
    lRect.y := lRect.y + 2;
    lRect.w := lRect.w - 24;
    lRect.h := lRect.h - 3;
    SDL_FillRect( MainWindow.DisplaySurface, @@lRect, SDL_MapRGB( MainWindow.DisplaySurface.format, 0, 0, 0 ) );
    SDL_BlitSurface( SelectRect[ ixSelectedShirt ].FText, nil, MainWindow.DisplaySurface, @@lRect );
    lRect.x := InfoRect[ Ord( moShirtColour ) ].FRect.x + SelectRect[ ixSelectedShirt ].FText.w + 3;
    SDL_BlitSurface( DXTextMessage[ 0 ], nil, MainWindow.DisplaySurface, @@lRect );

    lRect := InfoRect[ Ord( moPantsColour ) ].FRect;
    lRect.x := lRect.x + 2;
    lRect.y := lRect.y + 2;
    lRect.w := lRect.w - 24;
    lRect.h := lRect.h - 3;
    SDL_FillRect( MainWindow.DisplaySurface, @@lRect, SDL_MapRGB( MainWindow.DisplaySurface.format, 0, 0, 0 ) );
    SDL_BlitSurface( SelectRect[ ixSelectedPants ].FText, nil, MainWindow.DisplaySurface, @@lRect );
    lRect.x := InfoRect[ Ord( moPantsColour ) ].FRect.x + SelectRect[ ixSelectedPants ].FText.w + 3;
    SDL_BlitSurface( DXTextMessage[ 1 ], nil, MainWindow.DisplaySurface, @@lRect );

    lRect := InfoRect[ Ord( moHairColour ) ].FRect;
    lRect.x := lRect.x + 2;
    lRect.y := lRect.y + 2;
    lRect.w := lRect.w - 24;
    lRect.h := lRect.h - 3;
    SDL_FillRect( MainWindow.DisplaySurface, @@lRect, SDL_MapRGB( MainWindow.DisplaySurface.format, 0, 0, 0 ) );
    SDL_BlitSurface( SelectRect[ ixSelectedHair ].FText, nil, MainWindow.DisplaySurface, @@lRect );
    lRect.x := InfoRect[ Ord( moHairColour ) ].FRect.x + SelectRect[ ixSelectedHair ].FText.w + 3;
    SDL_BlitSurface( DXTextMessage[ 2 ], nil, MainWindow.DisplaySurface, @@lRect );

    lRect := InfoRect[ Ord( moHairStyle ) ].FRect;
    lRect.x := lRect.x + 2;
    lRect.y := lRect.y + 2;
    lRect.w := lRect.w - 24;
    lRect.h := lRect.h - 3;
    SDL_FillRect( MainWindow.DisplaySurface, @@lRect, SDL_MapRGB( MainWindow.DisplaySurface.format, 0, 0, 0 ) );
    SDL_BlitSurface( SelectRect[ ixSelectedHairStyle ].FText, nil, MainWindow.DisplaySurface, @@lRect );
    if ixSelectedHairStyle < 14 then
    begin
      lRect.x := InfoRect[ Ord( moHairStyle ) ].FRect.x + SelectRect[ ixSelectedHairStyle ].FText.w + 3;
      SDL_BlitSurface( DXTextMessage[ 2 ], nil, MainWindow.DisplaySurface, @@lRect )
    end;

    lRect := InfoRect[ Ord( moBeard ) ].FRect;
    lRect.x := lRect.x + 2;
    lRect.y := lRect.y + 2;
    lRect.w := lRect.w - 24;
    lRect.h := lRect.h - 3;
    SDL_FillRect( MainWindow.DisplaySurface, @@lRect, SDL_MapRGB( MainWindow.DisplaySurface.format, 0, 0, 0 ) );
    //SDL_BlitSurface( SelectRect[ ixSelectedBeard ].FText, nil, MainWindow.DisplaySurface, @@lRect );
    //lRect.x := SelectRect[ ixSelectedBeard ].FText.w + 10;
    if ixSelectedBeard = 16 then
      SDL_BlitSurface( DXTextMessage[ 3 ], nil, MainWindow.DisplaySurface, @@lRect )
    else
      SDL_BlitSurface( DXTextMessage[ 4 ], nil, MainWindow.DisplaySurface, @@lRect );

    lRect := InfoRect[ Ord( moTrainingStyle ) ].FRect;
    lRect.x := lRect.x + 2;
    lRect.y := lRect.y + 2;
    lRect.w := lRect.w - 24;
    lRect.h := lRect.h - 3;
    SDL_FillRect( MainWindow.DisplaySurface, @@lRect, SDL_MapRGB( MainWindow.DisplaySurface.format, 0, 0, 0 ) );
    //lRect.x := InfoRect[ Ord( moTrainingStyle ) ].FRect.x + SelectRect[ ixSelectedHairStyle ].FText.w + 3;
    //SDL_BlitSurface( SelectRect[ ixSelectedTraining ].FText, nil, MainWindow.DisplaySurface, @@lRect );
    case ixSelectedTraining of
      18 :
      begin
        SDL_BlitSurface( DXTextMessage[ 5 ], nil, MainWindow.DisplaySurface, @@lRect )
      end;
      19 :
      begin
        SDL_BlitSurface( DXTextMessage[ 6 ], nil, MainWindow.DisplaySurface, @@lRect )
      end;
      20 :
      begin
        SDL_BlitSurface( DXTextMessage[ 7 ], nil, MainWindow.DisplaySurface, @@lRect )
      end;
    end;

    if Player.Name <> '' then
    begin
      lRect := InfoRect[ Ord( moCharacterName ) ].FRect;
      lRect.x := lRect.x + 2;
      lRect.y := lRect.y + 2;
      lRect.w := lRect.w - 24;
      lRect.h := lRect.h - 3;
      SDL_BlitSurface( DXPlayerName, nil, MainWindow.DisplaySurface, @@lRect );
    end;

    // Draw the Stats
    for x := Low( StatRect ) to High( StatRect ) do
    begin
      lRect := StatRect[ x ].FRect;
      SDL_BlitSurface( StatRect[ x ].FInfo, nil, MainWindow.DisplaySurface, @@lRect );
    end;

    SDL_BlitSurface( DXLeftArrow, nil, MainWindow.DisplaySurface, @@LeftArrowRect );
    SDL_BlitSurface( DXRightArrow, nil, MainWindow.DisplaySurface, @@RightArrowRect );
  except
    on E: Exception do
      Log.LogError( E.Message, FailName );
  end;
end;

procedure TNewGame.Update(aElapsedTime: single);
begin
  inherited;

end;

{ TCharacter }

constructor TCharacter.Create;
begin
  inherited;
  BaseStrength := 7;
  BaseCoordination := 7;
  BaseConstitution := 7;
  BaseMysticism := 5;
  BaseCombat := 5;
  BaseStealth := 5;
  BasePerception := 10;
  BaseCharm := 10;
  BaseHealingRate := 10;
  BaseRechargeRate := 10;
  BaseHitPoints := 20;
  BaseMana := 10;
  BaseAttackRecovery := 12;
  BaseHitRecovery := 0;
  TrainingPoints := 0;
end;

end.

@


1.12
log
@More Cross-Platform additions and amendments
@
text
@d4 1
a4 1
  $Id: NewGame.pas,v 1.11 2005/06/01 20:24:27 savage Exp $
d66 3
d147 4
d246 1
a246 1
    DXTextMessage : array[ 0..7 ] of PSDL_Surface;
d275 1
a275 1
    iPickListLow, iPickListHigh : integer;
d571 1
a571 1
    SelectRect[ i ].FInfo := GameFont.DrawText( TextMessage[ 67 ], InfoPanel.w, InfoPanel.h );
d574 1
a574 1
    SelectRect[ i ].FRect.y := 160;
d578 1
a578 1
    SelectRect[ i ].FInfo := GameFont.DrawText( TextMessage[ 68 ], InfoPanel.w, InfoPanel.h );
d585 1
a585 1
    SelectRect[ i ].FInfo := GameFont.DrawText( TextMessage[ 69 ], InfoPanel.w, InfoPanel.h );
d859 1
a859 1
    GameFont.FontSize := 18;
d869 4
a872 1
      DXTextMessage[ i ] := GameFont.DrawText( TextMessage[ i ] );
d1279 1
a1279 3
        if PointIsInRect( CurrentPos, ContinueRect.x, ContinueRect.y, ContinueRect.x + ContinueRect.w, ContinueRect.y + ContinueRect.h )
        and ( Player.Name <> '' )
        and ( Player.TrainingPoints = 0 ) then
d1311 9
a1319 1
      
d1387 7
a1393 1
              SDL_BlitSurface( DXContinue, nil, MainWindow.DisplaySurface, @@ContinueRect );
d1452 1
a1452 1
            lRect.y := 134;
d1474 16
a1489 1
          SDL_BlitSurface( SelectRect[ x ].FText, nil, MainWindow.DisplaySurface, @@SelectRect[ x ].FRect );
d1558 13
a1570 11
    if ixSelectedTraining = 18 then
    begin
      SDL_BlitSurface( DXTextMessage[ 5 ], nil, MainWindow.DisplaySurface, @@lRect )
    end;
    if ixSelectedTraining = 19 then
    begin
      SDL_BlitSurface( DXTextMessage[ 6 ], nil, MainWindow.DisplaySurface, @@lRect )
    end;
    if ixSelectedTraining = 20 then
    begin
      SDL_BlitSurface( DXTextMessage[ 7 ], nil, MainWindow.DisplaySurface, @@lRect )
@


1.11
log
@Fix for Linux case sensitivity issues
@
text
@d4 1
a4 1
  $Id: NewGame.pas,v 1.10 2005/05/28 16:31:28 savage Exp $
d66 3
d287 1
d865 1
a865 1
    DXBack := SDL_LoadBMP( PChar( SoASettings.InterfacePath + '/' + SoASettings.LanguagePath + '/' + 'charcreate.bmp' ) );
d868 1
a868 1
    DXSelectRect := SDL_LoadBMP( PChar( SoASettings.InterfacePath + '/' + 'chaRedoval.bmp' ) );
d871 1
a871 1
    DXBlack := SDL_LoadBMP( PChar( SoASettings.InterfacePath + '/' + 'chaBlack.bmp' ) );
d874 1
a874 1
    DXContinue := SDL_LoadBMP( PChar( SoASettings.InterfacePath + '/' + SoASettings.LanguagePath + '/' + 'chaContinue.bmp' ) );
d877 1
a877 1
    DXCancel := SDL_LoadBMP( PChar( SoASettings.InterfacePath + '/' + SoASettings.LanguagePath + '/' + 'chaCancel.bmp' ) );
d880 1
a880 1
    DXLeftArrow := SDL_LoadBMP( PChar( SoASettings.InterfacePath + '/' + 'leftarrow.bmp' ) );
d883 1
a883 1
    DXRightArrow := SDL_LoadBMP( PChar( SoASettings.InterfacePath + '/' + 'rightarrow.bmp' ) );
d886 1
a886 1
    DXPickList := SDL_LoadBMP( PChar( SoASettings.InterfacePath + '/' + SoASettings.LanguagePath + '/' + 'chaChooseBox.bmp' ) );
@


1.10
log
@StatChanges are now reflected, You cannot click Continue unless TrainingPoints are 0 and you have entered a CharacterName
@
text
@d4 1
a4 1
  $Id: NewGame.pas,v 1.9 2005/05/28 09:56:10 savage Exp $
d66 3
d861 1
a861 1
    DXBack := SDL_LoadBMP( PChar( SoASettings.InterfacePath + '/' + SoASettings.LanguagePath + '/' + 'CharCreate.bmp' ) );
d864 1
a864 1
    DXSelectRect := SDL_LoadBMP( PChar( SoASettings.InterfacePath + '/' + 'chaRedOval.bmp' ) );
@


1.9
log
@Get Selections working correctly.
@
text
@d4 1
a4 1
  $Id: NewGame.pas,v 1.8 2005/05/25 23:15:42 savage Exp $
d66 3
d160 29
d190 29
a218 20
    BaseStrength : Integer;
    BaseCoordination : Integer;
    BaseConstitution : Integer;
    BaseMysticism : Integer;
    BaseCombat : Integer;
    BaseStealth : Integer;
    BaseMovement : Single;
    BasePerception : Integer;
    BaseCharm : Integer;
    BaseHealingRate : Integer;
    BaseRechargeRate : Integer;
    BaseHitPoints : Single;
    BaseMana : Single;
    BaseAttackRecovery : Integer;
    BaseAttackBonus : Single;
    BaseDefense : Single;
    BaseHitRecovery : integer;
    Damage : TDamageProfile;
    Resistance : TDamageResistanceProfile;
    TrainingPoints : Integer;
d239 2
a240 1
    StatAdjustments : array[ 0..7 ] of integer; //used to see if we've added points to a stat or not
d244 1
a244 1
    Damage : TDamageProfile;
d254 1
a254 1
    TrainingPoints : integer;
d266 1
d270 1
a270 1
    procedure Render; override;
d273 2
a274 1
    procedure KeyDown( var Key : TSDLKey; Shift : TSDLMod; unicode : UInt16 ); override;
d284 3
a286 1
  ListBoxDialog, sdlgameinterface, Math;
d577 56
d674 6
d743 2
a744 2
var
  i : integer;
d754 1
a754 1
    Damage := Player.Damage;
d764 1
a764 1
    TrainingPoints := Player.TrainingPoints;
d766 1
a766 1
    for i := 0 to 7 do
d769 1
a769 1
    end;
d778 9
d913 1
a914 1
    LoadBaseValues;
d929 1
a929 1
  x : integer;
d962 72
d1111 41
d1305 39
d1537 7
d1552 6
@


1.8
log
@Latest Changes
@
text
@d4 1
a4 1
  $Id: NewGame.pas,v 1.3 2005/05/13 14:02:49 savage Exp $
d66 3
d191 3
a193 2
    TextMessage : array[ 0..104 ] of string;
    ContinueRect, CancelRect, LeftArrowRect, RightArrowRect : TSDL_Rect;
d199 1
a199 1
    StatName : array[ 0..1, 0..11 ] of string;
a250 1
  C : TSDL_Color;
a252 15
    C.r := 231;
    C.g := 156;
    C.b := 0;
    GameFont.ForeGroundColour := C;
    C.r := 0;
    C.g := 0;
    C.b := 0;
    GameFont.BackGroundColour := C;
    {if SoASettings.UseSmallFont then
      GameFont.FontSize := 13
    else}
    GameFont.FontSize := 18;


  
d566 6
d590 1
d596 1
a598 1
        MainWindow.Rendering := false;
d645 1
a645 1
    //we store thse values so that we can keep the player from lowering his score beyon its start
d713 1
d717 13
d736 5
d790 5
d821 3
a823 1
        if PointIsInRect( CurrentPos, ContinueRect.x, ContinueRect.y, ContinueRect.x + ContinueRect.w, ContinueRect.y + ContinueRect.h ) then
d858 2
d925 3
d940 4
d956 4
d972 4
d988 4
d1004 3
a1006 2
            if PointIsInRect( CurrentPos, SelectRect[ x ].FRect.x, SelectRect[ x ].FRect.y, SelectRect[ x ].FRect.x + SelectRect[ x ].FRect.w, SelectRect[ x ].FRect.y + SelectRect[ x ].FRect.h ) then
            begin
a1007 1
            end;
d1032 3
a1034 1
        if PointIsInRect( CurrentPos, ContinueRect.x, ContinueRect.y, ContinueRect.x + ContinueRect.w, ContinueRect.y + ContinueRect.h ) then
d1169 3
d1188 2
d1198 2
d1208 2
d1218 5
d1230 6
a1235 1
    SDL_BlitSurface( SelectRect[ ixSelectedBeard ].FText, nil, MainWindow.DisplaySurface, @@lRect );
d1243 14
a1256 1
    SDL_BlitSurface( SelectRect[ ixSelectedTraining ].FText, nil, MainWindow.DisplaySurface, @@lRect );
@


1.7
log
@Changed so that german Continue appears correctly.
@
text
@d3 4
d66 3
d98 11
a108 3
    moNone,
    moContinue,
    moCancel,
a114 1
    moName,
a115 1
    moTrainingPoints,
d132 2
a133 8
    moStrength,
    moCoordination,
    moConstitution,
    moPerception,
    moCharm,
    moMysticism,
    moCombat,
    moStealth,
d135 4
a138 1
    moRightArrow );
d152 2
d175 2
d181 1
a181 2
    DXCircle : PSDL_Surface; //circle used for outline
    DXBox : PSDL_Surface;
d186 2
d215 2
a216 1
    
a219 1
    function ShowListBox( aX, aY : integer; aMoOptions : TMouseOverNewOptions ): integer;
a220 1
    Character : TCharacter;
d388 2
a389 2
     //now for the selectable text
     //Shirt color
a390 4
    SelectRect[ i ].FRect.x := -148;
    SelectRect[ i ].FRect.y := 80;
    SelectRect[ i ].FRect.w := -186 - InfoRect[ i ].FRect.x;
    SelectRect[ i ].FRect.h := 101 - InfoRect[ i ].FRect.y;
d393 4
a397 4
    SelectRect[ i ].FRect.x := -197;
    SelectRect[ i ].FRect.y := 80;
    SelectRect[ i ].FRect.w := -258 - InfoRect[ i ].FRect.x;
    SelectRect[ i ].FRect.h := 101 - InfoRect[ i ].FRect.y;
d400 4
a404 4
    SelectRect[ i ].FRect.x := -269;
    SelectRect[ i ].FRect.y := 80;
    SelectRect[ i ].FRect.w := -320 - InfoRect[ i ].FRect.x;
    SelectRect[ i ].FRect.h := 101 - InfoRect[ i ].FRect.y;
d407 4
a411 4
    SelectRect[ i ].FRect.x := -331;
    SelectRect[ i ].FRect.y := 80;
    SelectRect[ i ].FRect.w := -382 - InfoRect[ i ].FRect.x;
    SelectRect[ i ].FRect.h := 101 - InfoRect[ i ].FRect.y;
d414 4
a419 4
    SelectRect[ i ].FRect.x := -148;
    SelectRect[ i ].FRect.y := 110;
    SelectRect[ i ].FRect.w := -186 - InfoRect[ i ].FRect.x;
    SelectRect[ i ].FRect.h := 131 - InfoRect[ i ].FRect.y;
d422 4
a426 4
    SelectRect[ i ].FRect.x := -197;
    SelectRect[ i ].FRect.y := 110;
    SelectRect[ i ].FRect.w := -258 - InfoRect[ i ].FRect.x;
    SelectRect[ i ].FRect.h := 131 - InfoRect[ i ].FRect.y;
d429 4
a433 4
    SelectRect[ i ].FRect.x := -269;
    SelectRect[ i ].FRect.y := 110;
    SelectRect[ i ].FRect.w := -320 - InfoRect[ i ].FRect.x;
    SelectRect[ i ].FRect.h := 131 - InfoRect[ i ].FRect.y;
d436 4
a440 4
    SelectRect[ i ].FRect.x := -331;
    SelectRect[ i ].FRect.y := 110;
    SelectRect[ i ].FRect.w := -382 - InfoRect[ i ].FRect.x;
    SelectRect[ i ].FRect.h := 131 - InfoRect[ i ].FRect.y;
d443 4
a448 4
    SelectRect[ i ].FRect.x := -149;
    SelectRect[ i ].FRect.y := 140;
    SelectRect[ i ].FRect.w := -201 - InfoRect[ i ].FRect.x;
    SelectRect[ i ].FRect.h := 161 - InfoRect[ i ].FRect.y;
d451 4
a455 4
    SelectRect[ i ].FRect.x := -210;
    SelectRect[ i ].FRect.y := 140;
    SelectRect[ i ].FRect.w := -271 - InfoRect[ i ].FRect.x;
    SelectRect[ i ].FRect.h := 161 - InfoRect[ i ].FRect.y;
d458 4
a462 4
    SelectRect[ i ].FRect.x := -281;
    SelectRect[ i ].FRect.y := 140;
    SelectRect[ i ].FRect.w := -320 - InfoRect[ i ].FRect.x;
    SelectRect[ i ].FRect.h := 161 - InfoRect[ i ].FRect.y;
d465 4
a469 4
    SelectRect[ i ].FRect.x := 329;
    SelectRect[ i ].FRect.y := 140;
    SelectRect[ i ].FRect.w := 373 - InfoRect[ i ].FRect.x;
    SelectRect[ i ].FRect.h := 161 - InfoRect[ i ].FRect.y;
d472 4
a477 4
    SelectRect[ i ].FRect.x := 149;
    SelectRect[ i ].FRect.y := 170;
    SelectRect[ i ].FRect.w := 196 - InfoRect[ i ].FRect.x;
    SelectRect[ i ].FRect.h := 191 - InfoRect[ i ].FRect.y;
d480 4
a484 4
    SelectRect[ i ].FRect.x := 206;
    SelectRect[ i ].FRect.y := 170;
    SelectRect[ i ].FRect.w := 249 - InfoRect[ i ].FRect.x;
    SelectRect[ i ].FRect.h := 191 - InfoRect[ i ].FRect.y;
d487 4
a491 4
    SelectRect[ i ].FRect.x := 259;
    SelectRect[ i ].FRect.y := 170;
    SelectRect[ i ].FRect.w := 331;
    SelectRect[ i ].FRect.h := 194;
d494 4
a498 4
    SelectRect[ i ].FRect.x := 340;
    SelectRect[ i ].FRect.y := 170;
    SelectRect[ i ].FRect.w := 382 - InfoRect[ i ].FRect.x;
    SelectRect[ i ].FRect.h := 191 - InfoRect[ i ].FRect.y;
d501 4
a506 4
    SelectRect[ i ].FRect.x := 149;
    SelectRect[ i ].FRect.y := 200;
    SelectRect[ i ].FRect.w := 185 - InfoRect[ i ].FRect.x;
    SelectRect[ i ].FRect.h := 223 - InfoRect[ i ].FRect.y;
d509 4
a513 4
    SelectRect[ i ].FRect.x := 194;
    SelectRect[ i ].FRect.y := 200;
    SelectRect[ i ].FRect.w := 239 - InfoRect[ i ].FRect.x;
    SelectRect[ i ].FRect.h := 223 - InfoRect[ i ].FRect.y;
d516 4
a522 4
    SelectRect[ i ].FRect.x := 40;
    SelectRect[ i ].FRect.y := 270;
    SelectRect[ i ].FRect.w := 113 - InfoRect[ i ].FRect.x;
    SelectRect[ i ].FRect.h := 293 - InfoRect[ i ].FRect.y;
d525 4
a529 4
    SelectRect[ i ].FRect.x := 127;
    SelectRect[ i ].FRect.y := 270;
    SelectRect[ i ].FRect.w := 200 - InfoRect[ i ].FRect.x;
    SelectRect[ i ].FRect.h := 293 - InfoRect[ i ].FRect.y;
d532 4
a536 4
    SelectRect[ i ].FRect.x := 216;
    SelectRect[ i ].FRect.y := 270;
    SelectRect[ i ].FRect.w := 270 - InfoRect[ i ].FRect.x;
    SelectRect[ i ].FRect.h := 293 - InfoRect[ i ].FRect.y;
d539 4
d553 1
a553 2
  SDL_FreeSurface( DXCircle ); //circle used for outline
  SDL_FreeSurface( DXBox );
d559 2
d589 13
a601 4
    case Key of
      SDLK_RETURN :
        begin
          NextGameInterface := TMainMenu;
d603 2
d606 22
a627 3
      SDLK_ESCAPE :
        begin
          NextGameInterface := TMainMenu;
d629 1
a630 1
    MainWindow.Rendering := false;
d644 6
d651 11
a661 11
    Damage := Character.Damage;
    Resistance := Character.Resistance;
    BaseStrength := Character.BaseStrength;
    BaseCoordination := Character.BaseCoordination;
    BaseConstitution := Character.BaseConstitution;
    BasePerception := Character.BasePerception;
    BaseCharm := Character.BaseCharm;
    BaseMysticism := Character.BaseMysticism;
    BaseCombat := Character.BaseCombat;
    BaseStealth := Character.BaseStealth;
    TrainingPoints := Character.TrainingPoints;
d667 8
d730 2
a731 2
    DXCircle := SDL_LoadBMP( PChar( SoASettings.InterfacePath + '/' + 'chaRedOval.bmp' ) );
    SDL_SetColorKey( DXCircle, Flags, SDL_MapRGB( DXCircle.format, 0, 255, 255 ) );
a735 3
    DXBox := SDL_LoadBMP( PChar( SoASettings.InterfacePath + '/' + SoASettings.LanguagePath + '/' + 'chaChooseBox.bmp' ) );
    SDL_SetColorKey( DXBox, Flags, SDL_MapRGB( DXBox.format, 0, 255, 255 ) );

d748 3
d778 1
a778 1
    //LoadBaseValues;
d781 2
d792 3
d798 174
a971 27
    if PointIsInRect( CurrentPos, 452, 133, 467, 159 ) then
      ixSelectedTraining := ShowListBox( 313, 175, moTrainingStyle )
    else if PointIsInRect( CurrentPos, 265, 239, 279, 264  ) then
      ixSelectedShirt := ShowListBox( 280, 239, moShirtColour )
    else if PointIsInRect( CurrentPos, 265, 280, 279, 295 ) then
      ixSelectedPants := ShowListBox( 280, 281, moPantsColour )
    else if PointIsInRect( CurrentPos, 265, 322, 279, 337 ) then
      ixSelectedHair := ShowListBox( 280, 323, moHairColour )
    else if PointIsInRect( CurrentPos, 265, 364, 279, 379 ) then
      ixSelectedHairStyle := ShowListBox( 280, 365, moHairStyle )
    else if PointIsInRect( CurrentPos, 265, 408, 279, 423 ) then
      ixSelectedBeard := ShowListBox( 280, 409, moBeard )
    else if PointIsInRect( CurrentPos, CancelRect.x, CancelRect.y, CancelRect.x + CancelRect.w, CancelRect.y + CancelRect.h ) then
    begin
      NextGameInterface := TMainMenu;
      MainWindow.Rendering := false;
    end
    else if PointIsInRect( CurrentPos, ContinueRect.x, ContinueRect.y, ContinueRect.x + ContinueRect.w, ContinueRect.y + ContinueRect.h ) then
    begin
      // Check to see we have all data before starting the new game
      NextGameInterface := TMainMenu;
      MainWindow.Rendering := false;
    end
    else if PointIsInRect( CurrentPos, LeftArrowRect.x, LeftArrowRect.y, LeftArrowRect.x + LeftArrowRect.w, LeftArrowRect.y + LeftArrowRect.h ) then
      // Set Previous Character
    else if PointIsInRect( CurrentPos, RightArrowRect.x, RightArrowRect.y, RightArrowRect.x + RightArrowRect.w, RightArrowRect.y + RightArrowRect.h ) then
      // Set Next Character
d982 1
a982 1
  i : integer;
d986 2
a987 46
    MouseOverOptions := moNone;
    if PointIsInRect( CurrentPos, 113, 92, 261, 222 ) then
      MouseOverOptions := moAppearance
    else if PointIsInRect( CurrentPos, 113, 236, 261, 264 ) then
      MouseOverOptions := moShirtColour
    else if PointIsInRect( CurrentPos, 113, 278, 261, 306 ) then
      MouseOverOptions := moPantsColour
    else if PointIsInRect( CurrentPos, 113, 320, 261, 348 ) then
      MouseOverOptions := moHairColour
    else if PointIsInRect( CurrentPos, 113, 363, 261, 391 ) then
      MouseOverOptions := moHairStyle
    else if PointIsInRect( CurrentPos, 113, 406, 261, 434 ) then
      MouseOverOptions := moBeard
    else if PointIsInRect( CurrentPos, 300, 92, 448, 120 ) then
      MouseOverOptions := moName
    else if PointIsInRect( CurrentPos, 300, 132, 448, 160 ) then
      MouseOverOptions := moTrainingStyle
    else if PointIsInRect( CurrentPos, 288, 205, 460, 236 ) then
      MouseOverOptions := moTrainingPoints
    else if PointIsInRect( CurrentPos, 288, 240, 387, 264 ) then
      MouseOverOptions := moStrength
    else if PointIsInRect( CurrentPos, 288, 265, 387, 289 ) then
      MouseOverOptions := moCoordination
    else if PointIsInRect( CurrentPos, 288, 290, 387, 314 ) then
      MouseOverOptions := moConstitution
    else if PointIsInRect( CurrentPos, 288, 315, 387, 339 ) then
      MouseOverOptions := moPerception
    else if PointIsInRect( CurrentPos, 288, 340, 387, 364 ) then
      MouseOverOptions := moCharm
    else if PointIsInRect( CurrentPos, 288, 365, 387, 389 ) then
      MouseOverOptions := moMysticism
    else if PointIsInRect( CurrentPos, 288, 390, 387, 414 ) then
      MouseOverOptions := moCombat
    else if PointIsInRect( CurrentPos, 288, 415, 387, 439 ) then
      MouseOverOptions := moStealth
    else if PointIsInRect( CurrentPos, ContinueRect.x, ContinueRect.y, ContinueRect.x + ContinueRect.w, ContinueRect.y + ContinueRect.h ) then
      MouseOverOptions := moContinue
    else if PointIsInRect( CurrentPos, CancelRect.x, CancelRect.y, CancelRect.x + CancelRect.w, CancelRect.y + CancelRect.h ) then
      MouseOverOptions := moCancel
    else if PointIsInRect( CurrentPos, LeftArrowRect.x, LeftArrowRect.y, LeftArrowRect.x + LeftArrowRect.w, LeftArrowRect.y + LeftArrowRect.h ) then
      MouseOverOptions := moLeftArrow
    else if PointIsInRect( CurrentPos, RightArrowRect.x, RightArrowRect.y, RightArrowRect.x + RightArrowRect.w, RightArrowRect.y + RightArrowRect.h ) then
      MouseOverOptions := moRightArrow
    else
    begin
      for i := 0 to 15 do
d989 10
a998 1
        if PointIsInRect( CurrentPos, ArrowRect[ i ].FRect.x, ArrowRect[ i ].FRect.y, ArrowRect[ i ].FRect.x + ArrowRect[ i ].FRect.w, ArrowRect[ i ].FRect.y + ArrowRect[ i ].FRect.h ) then
d1000 17
a1016 2
          MouseOverOptions := TMouseOverNewOptions( i + 12 );
          break;
d1019 5
d1034 3
d1040 2
a1041 2
    case MouseOverOptions of
      moName :
d1043 15
a1057 2
        SDL_BlitSurface( InfoRect[ 10 ].FInfo, nil, MainWindow.DisplaySurface, @@InfoPanel );
      end;
d1059 3
a1061 8
      moAppearance :
      begin
        SDL_BlitSurface( InfoRect[ 11 ].FInfo, nil, MainWindow.DisplaySurface, @@InfoPanel );
      end;
      
      moShirtColour :
      begin
        SDL_BlitSurface( InfoRect[ 12 ].FInfo, nil, MainWindow.DisplaySurface, @@InfoPanel );
d1064 1
a1064 1
      moPantsColour :
d1066 58
a1123 34
        SDL_BlitSurface( InfoRect[ 13 ].FInfo, nil, MainWindow.DisplaySurface, @@InfoPanel );
      end;

      moHairColour :
      begin
        SDL_BlitSurface( InfoRect[ 14 ].FInfo, nil, MainWindow.DisplaySurface, @@InfoPanel );
      end;

      moHairStyle :
      begin
        SDL_BlitSurface( InfoRect[ 15 ].FInfo, nil, MainWindow.DisplaySurface, @@InfoPanel );
      end;

      moBeard :
      begin
        SDL_BlitSurface( InfoRect[ 16 ].FInfo, nil, MainWindow.DisplaySurface, @@InfoPanel );
      end;

      moTrainingStyle :
      begin
        SDL_BlitSurface( InfoRect[ 17 ].FInfo, nil, MainWindow.DisplaySurface, @@InfoPanel );
      end;

      moTrainingPoints :
        SDL_BlitSurface( InfoRect[ 0 ].FInfo, nil, MainWindow.DisplaySurface, @@InfoPanel );
        
      moStrength :
        SDL_BlitSurface( InfoRect[ 2 ].FInfo, nil, MainWindow.DisplaySurface, @@InfoPanel );

      moCoordination :
        SDL_BlitSurface( InfoRect[ 3 ].FInfo, nil, MainWindow.DisplaySurface, @@InfoPanel );

      moConstitution :
        SDL_BlitSurface( InfoRect[ 4 ].FInfo, nil, MainWindow.DisplaySurface, @@InfoPanel );
d1125 1
a1125 2
      moPerception :
        SDL_BlitSurface( InfoRect[ 5 ].FInfo, nil, MainWindow.DisplaySurface, @@InfoPanel );
d1127 1
a1127 13
      moCharm :
        SDL_BlitSurface( InfoRect[ 6 ].FInfo, nil, MainWindow.DisplaySurface, @@InfoPanel );

      moMysticism :
        SDL_BlitSurface( InfoRect[ 7 ].FInfo, nil, MainWindow.DisplaySurface, @@InfoPanel );

      moCombat :
        SDL_BlitSurface( InfoRect[ 8 ].FInfo, nil, MainWindow.DisplaySurface, @@InfoPanel );

      moStealth :
        SDL_BlitSurface( InfoRect[ 9 ].FInfo, nil, MainWindow.DisplaySurface, @@InfoPanel );

      moContinue :
d1129 1
a1129 1
          SDL_BlitSurface( DXContinue, nil, MainWindow.DisplaySurface, @@ContinueRect );
d1131 2
d1134 47
a1180 4
      moCancel :
        begin
          SDL_BlitSurface( DXCancel, nil, MainWindow.DisplaySurface, @@CancelRect );
        end;
d1182 8
a1189 2
      moStrengthMinus..moStealthPlus :
        SDL_BlitSurface( ArrowRect[ Ord( MouseOverOptions ) - 12 ].FInfo, nil, MainWindow.DisplaySurface, @@InfoPanel );
d1200 3
a1202 6
function TNewGame.ShowListBox( aX, aY : integer; aMoOptions : TMouseOverNewOptions ) : integer;
const
  FailName : string = 'TNewGame.ShowListBox';
var
  ListBoxDialog : TListBoxDialog;
  i, x, iLow, iHigh : integer;
d1204 16
a1219 64
  Result := -1;
  try
    iLow := 0;
    iHigh := 3;
    ListBoxDialog := TListBoxDialog.Create( SoAoSGame, aX, aY );
    try
      case aMoOptions of
        moShirtColour :
        begin
          iLow := 0;
          iHigh := 3;
        end;

        moPantsColour :
        begin
          iLow := 4;
          iHigh := 7;
        end;

        moHairColour :
        begin
          iLow := 8;
          iHigh := 11;
        end;

        moHairStyle :
        begin
          iLow := 12;
          iHigh := 15;
        end;

        moBeard :
        begin
          iLow := 16;
          iHigh := 17;
        end;

        moTrainingStyle :
        begin
          iLow := 18;
          iHigh := 20;
        end;
      end;

      x := 0;
      SetLength( ListBoxDialog.ListItems, iHigh - iLow );
      for i := iLow to iHigh do
      begin
        ListBoxDialog.ListItems[ x ].FInfo := SelectRect[ i ].FInfo;
        ListBoxDialog.ListItems[ X ].FText := SelectRect[ i ].FText;
        inc( x );
      end;
    
      ListBoxDialog.LoadSurfaces;
      SoAoSGame.Show;
      Result := ListBoxDialog.SelectedIndex;
    finally
      ListBoxDialog.Free;
    end;
    ResetInputManager;
  except
    on E: Exception do
      Log.LogError( E.Message, FailName );
  end;
@


1.6
log
@Various Changes and bug fixes. Main work on the NewGame screen.
@
text
@d62 3
d681 1
a681 1
    SDL_SetColorKey( DXContinue, Flags, SDL_MapRGB( DXContinue.format, 0, 255, 255 ) );
@


1.5
log
@Added Exception Logging
@
text
@d62 3
d91 1
d99 17
d123 3
a125 1
    moStealth );
d169 1
d171 2
a172 1
    ContinueRect, CancelRect : TSDL_Rect;
d219 1
a219 1
  ListBoxDialog;
d226 1
a230 1
  Flags : Cardinal;
d246 1
a246 1
    Flags := SDL_SRCCOLORKEY or SDL_RLEACCEL or SDL_HWACCEL;
d261 1
a261 1
      ArrowRect[ i ].FInfo := GameFont.DrawText( TextMessage[ 26 ] + StatName[ 0 ][ i + 1 ] + '.' );
d266 1
a266 1
        ArrowRect[ i + 8 ].FInfo := GameFont.DrawText( TextMessage[ 27 ] + StatName[ 0 ][ i + 1 ] + TextMessage[ 28 ] + StatName[ 0 ][ i + 1 ] + TextMessage[ 29 ], 188, 268 );
d271 1
a271 1
        ArrowRect[ i + 8 ].FInfo := GameFont.DrawText( TextMessage[ 30 ] + StatName[ 0 ][ i + 1 ] + TextMessage[ 31 ] + StatName[ 0 ][ i + 1 ] + TextMessage[ 29 ], 188, 268 );
d282 1
a282 1
    InfoRect[ 0 ].FInfo := GameFont.DrawText( TextMessage[ 32 ], 188, 268 );
d296 1
a296 1
    InfoRect[ 2 ].FInfo := GameFont.DrawText( TextMessage[ 33 ], 188, 268 ) ; //'Strength represents the physical strength of a character.  Strength affects '+
d298 1
a298 1
    InfoRect[ 3 ].FInfo := GameFont.DrawText( TextMessage[ 34 ], 188, 268 ); //'Coordination represents how agile a character is.  Coordination affects '+
d300 1
a300 1
    InfoRect[ 4 ].FInfo := GameFont.DrawText( TextMessage[ 35 ], 188, 268 ); //'Constitution represents a characters physical hardiness.  Constitution affects '+
d302 1
a302 1
    InfoRect[ 5 ].FInfo := GameFont.DrawText( TextMessage[ 36 ], 188, 268 ); //'Perception represents how well a character senses the area around him.';
d304 1
a304 1
    InfoRect[ 6 ].FInfo := GameFont.DrawText( TextMessage[ 37 ], 188, 268 ); //'Charm represents a character''s personal magnetism.  Charm affects the '+
d306 1
a306 1
    InfoRect[ 7 ].FInfo := GameFont.DrawText( TextMessage[ 38 ], 188, 268 ); //'Mysticism represents a character''s magical ability.  Mysticism affects '+
d308 1
a308 1
    InfoRect[ 8 ].FInfo := GameFont.DrawText( TextMessage[ 39 ], 188, 268 ); //'Combat represents a character''s fighting ability.  Combat affects '+
d310 1
a310 1
    InfoRect[ 9 ].FInfo := GameFont.DrawText( TextMessage[ 40 ], 188, 268 ); //'Stealth represents the character''s ability to move and avoid detection.';
d319 1
a319 1
    InfoRect[ i ].FInfo := GameFont.DrawText( TextMessage[ 41 ], 188, 268 );
d322 2
a323 2
    InfoRect[ i ].FRect.x := 102;
    InfoRect[ i ].FRect.y := 64;
d326 1
a326 1
    InfoRect[ i ].FInfo := GameFont.DrawText( TextMessage[ 42 ], 188, 268 );
d333 1
a333 1
    InfoRect[ i ].FInfo := GameFont.DrawText( TextMessage[ 43 ], 188, 268 );
d340 1
a340 1
    InfoRect[ i ].FInfo := GameFont.DrawText( TextMessage[ 44 ], 188, 268 );
d347 1
a347 1
    InfoRect[ i ].FInfo := GameFont.DrawText( TextMessage[ 45 ], 188, 268 );
d354 1
a354 1
    InfoRect[ i ].FInfo := GameFont.DrawText( TextMessage[ 46 ], 188, 268 );
d361 1
a361 1
    InfoRect[ i ].FInfo := GameFont.DrawText( TextMessage[ 47 ], 188, 268 );
d367 1
a367 1
    InfoRect[ i ].FInfo := GameFont.DrawText( TextMessage[ 48 ], 188, 268 ); //  Fighting training places an emphasis on your '+
d378 1
a378 1
    SelectRect[ i ].FInfo := GameFont.DrawText( TextMessage[ 49 ], 188, 268 );
d385 1
a385 1
    SelectRect[ i ].FInfo := GameFont.DrawText( TextMessage[ 50 ], 188, 268 );
d392 1
a392 1
    SelectRect[ i ].FInfo := GameFont.DrawText( TextMessage[ 51 ], 188, 268 );
d399 1
a399 1
    SelectRect[ i ].FInfo := GameFont.DrawText( TextMessage[ 52 ], 188, 268 );
d407 1
a407 1
    SelectRect[ i ].FInfo := GameFont.DrawText( TextMessage[ 53 ], 188, 268 );
d414 1
a414 1
    SelectRect[ i ].FInfo := GameFont.DrawText( TextMessage[ 54 ], 188, 268 );
d421 1
a421 1
    SelectRect[ i ].FInfo := GameFont.DrawText( TextMessage[ 55 ], 188, 268 );
d428 1
a428 1
    SelectRect[ i ].FInfo := GameFont.DrawText( TextMessage[ 56 ], 188, 268 );
d436 1
a436 1
    SelectRect[ i ].FInfo := GameFont.DrawText( TextMessage[ 57 ], 188, 268 );
d443 1
a443 1
    SelectRect[ i ].FInfo := GameFont.DrawText( TextMessage[ 58 ], 188, 268 );
d450 1
a450 1
    SelectRect[ i ].FInfo := GameFont.DrawText( TextMessage[ 59 ], 188, 268 );
d457 1
a457 1
    SelectRect[ i ].FInfo := GameFont.DrawText( TextMessage[ 60 ], 188, 268 );
d465 1
a465 1
    SelectRect[ i ].FInfo := GameFont.DrawText( TextMessage[ 61 ], 188, 268 );
d472 1
a472 1
    SelectRect[ i ].FInfo := GameFont.DrawText( TextMessage[ 62 ], 188, 268 );
d479 1
a479 1
    SelectRect[ i ].FInfo := GameFont.DrawText( TextMessage[ 63 ], 188, 268 );
d486 1
a486 1
    SelectRect[ i ].FInfo := GameFont.DrawText( TextMessage[ 64 ], 188, 268 );
d494 1
a494 1
    SelectRect[ i ].FInfo := GameFont.DrawText( TextMessage[ 65 ], 188, 268 );
d501 1
a501 1
    SelectRect[ i ].FInfo := GameFont.DrawText( TextMessage[ 66 ], 188, 268 );
d510 1
a510 1
    SelectRect[ i ].FInfo := GameFont.DrawText( TextMessage[ 67 ], 188, 268 );
d517 1
a517 1
    SelectRect[ i ].FInfo := GameFont.DrawText( TextMessage[ 68 ], 188, 268 );
d524 1
a524 1
    SelectRect[ i ].FInfo := GameFont.DrawText( TextMessage[ 69 ], 188, 268 );
d541 2
d653 1
a655 1
  Flags : Cardinal;
a658 3

    Flags := SDL_SRCCOLORKEY or SDL_RLEACCEL or SDL_HWACCEL;

d683 6
d699 15
d716 3
d742 16
a757 1
      ixSelectedBeard := ShowListBox( 280, 409, moBeard );
d767 2
d773 35
a807 1
    if PointIsInRect( CurrentPos, ContinueRect.x, ContinueRect.y, ContinueRect.x + ContinueRect.w, ContinueRect.y + ContinueRect.h ) then
d810 16
a825 1
      MouseOverOptions := moCancel;
d839 67
d915 3
d919 3
@


1.4
log
@ListBoxDialog used in New GUI
@
text
@d62 3
d191 1
d199 2
d207 13
a219 12
  C.r := 231;
  C.g := 156;
  C.b := 0;
  GameFont.ForeGroundColour := C;
  C.r := 0;
  C.g := 0;
  C.b := 0;
  GameFont.BackGroundColour := C;
  {if SoASettings.UseSmallFont then
    GameFont.FontSize := 13
  else}
  GameFont.FontSize := 18;
d221 1
a221 1
  Flags := SDL_SRCCOLORKEY or SDL_RLEACCEL or SDL_HWACCEL;
d223 26
a248 12
  LineHeight := 24;
   //first the ArrowRects
  for i := 0 to 7 do
  begin
    ArrowRect[ i ].FRect.x := 389;
    ArrowRect[ i + 8 ].FRect.x := 408;
    ArrowRect[ i ].FRect.w := 406 - ArrowRect[ i ].FRect.x;
    ArrowRect[ i + 8 ].FRect.w := 425 - ArrowRect[ i + 8 ].FRect.x;
    ArrowRect[ i ].FRect.y := 239 + i * LineHeight;
    ArrowRect[ i + 8 ].FRect.y := 239 + i * LineHeight;
    ArrowRect[ i ].FRect.h := ( 239 + i * LineHeight + LineHeight ) - ArrowRect[ i ].FRect.y;
    ArrowRect[ i + 8 ].FRect.h := ( 239 + i * LineHeight + LineHeight ) - ArrowRect[ i ].FRect.y;
d250 1
a250 2
    ArrowRect[ i ].FInfo := GameFont.DrawText( TextMessage[ 26 ] + StatName[ 0 ][ i + 1 ] + '.' );
    SDL_SetColorKey( ArrowRect[ i ].FInfo, Flags, SDL_MapRGB( ArrowRect[ i ].FInfo.format, 0, 0, 0 ) );
d252 8
a259 1
    if i < 5 then
d261 4
a264 7
      ArrowRect[ i + 8 ].FInfo := GameFont.DrawText( TextMessage[ 27 ] + StatName[ 0 ][ i + 1 ] + TextMessage[ 28 ] + StatName[ 0 ][ i + 1 ] + TextMessage[ 29 ], 188, 268 );
      SDL_SetColorKey( ArrowRect[ i + 8 ].FInfo, Flags, SDL_MapRGB( ArrowRect[ i + 8 ].FInfo.format, 0, 0, 0 ) );
    end
    else
    begin
      ArrowRect[ i + 8 ].FInfo := GameFont.DrawText( TextMessage[ 30 ] + StatName[ 0 ][ i + 1 ] + TextMessage[ 31 ] + StatName[ 0 ][ i + 1 ] + TextMessage[ 29 ], 188, 268 );
      SDL_SetColorKey( ArrowRect[ i + 8 ].FInfo, Flags, SDL_MapRGB( ArrowRect[ i + 8 ].FInfo.format, 0, 0, 0 ) );
d266 239
a504 252

  end; //end for

   //Training points
  InfoRect[ 0 ].FRect.x := 298;
  InfoRect[ 0 ].FRect.y := 212;
  InfoRect[ 0 ].FRect.w := 457 - InfoRect[ 0 ].FRect.x;
  InfoRect[ 0 ].FRect.h := 236 - InfoRect[ 0 ].FRect.y;
  InfoRect[ 0 ].FInfo := GameFont.DrawText( TextMessage[ 32 ], 188, 268 );
   //Primary->Stealth
  for i := 1 to 9 do
  begin
    InfoRect[ i ].FRect.x := 289;
    InfoRect[ i ].FRect.w := 457 - InfoRect[ i ].FRect.x;
    InfoRect[ i ].FRect.y := 239 + ( i - 2 ) * LineHeight;
    InfoRect[ i ].FRect.h := ( 239 + ( i - 2 ) * LineHeight + LineHeight ) - InfoRect[ i ].FRect.y;
  end;
  InfoRect[ 1 ].FRect.x := 0; //no longer used here
  InfoRect[ 1 ].FRect.w := 0;
  InfoRect[ 1 ].FInfo := nil; //Primary skills are your characters main traits.  These skills determine '+
                     //'your Secondary skills, Resistance modifiers and Damage modifers.  Training '+
                     //'points are used to increase your Primary skills.';
  InfoRect[ 2 ].FInfo := GameFont.DrawText( TextMessage[ 33 ], 188, 268 ) ; //'Strength represents the physical strength of a character.  Strength affects '+
                     //'how much damage a character inflicts in battle.';
  InfoRect[ 3 ].FInfo := GameFont.DrawText( TextMessage[ 34 ], 188, 268 ); //'Coordination represents how agile a character is.  Coordination affects '+
                     //'a character''s movement, recovery and resistance modifiers.';
  InfoRect[ 4 ].FInfo := GameFont.DrawText( TextMessage[ 35 ], 188, 268 ); //'Constitution represents a characters physical hardiness.  Constitution affects '+
                     //'a character''s healing rate and hit points.';
  InfoRect[ 5 ].FInfo := GameFont.DrawText( TextMessage[ 36 ], 188, 268 ); //'Perception represents how well a character senses the area around him.';
                     //'Perception affects a character''s...something.  Lord knows I''m stumped.';
  InfoRect[ 6 ].FInfo := GameFont.DrawText( TextMessage[ 37 ], 188, 268 ); //'Charm represents a character''s personal magnetism.  Charm affects the '+
                     //'prices a character can command when buying or selling items.';
  InfoRect[ 7 ].FInfo := GameFont.DrawText( TextMessage[ 38 ], 188, 268 ); //'Mysticism represents a character''s magical ability.  Mysticism affects '+
                     //'the character''s recharge rate and mana.';
  InfoRect[ 8 ].FInfo := GameFont.DrawText( TextMessage[ 39 ], 188, 268 ); //'Combat represents a character''s fighting ability.  Combat affects '+
                     //'the character''s damage modifiers.';
  InfoRect[ 9 ].FInfo := GameFont.DrawText( TextMessage[ 40 ], 188, 268 ); //'Stealth represents the character''s ability to move and avoid detection.';


  i := 10;
   //the characters name
  InfoRect[ i ].FRect.x := 301;
  InfoRect[ i ].FRect.y := 92;
  InfoRect[ i ].FRect.w := 448 - InfoRect[ i ].FRect.x;
  InfoRect[ i ].FRect.h := 120 - InfoRect[ i ].FRect.y;
  InfoRect[ i ].FInfo := GameFont.DrawText( TextMessage[ 41 ], 188, 268 );
   //the appearance
  inc( i );
  InfoRect[ i ].FRect.x := 102;
  InfoRect[ i ].FRect.y := 64;
  InfoRect[ i ].FRect.w := 281 - InfoRect[ i ].FRect.x;
  InfoRect[ i ].FRect.h := 221 - InfoRect[ i ].FRect.y;
  InfoRect[ i ].FInfo := GameFont.DrawText( TextMessage[ 42 ], 188, 268 );
   //shirt color
  inc( i );
  InfoRect[ i ].FRect.x := 113;
  InfoRect[ i ].FRect.y := 236;
  InfoRect[ i ].FRect.w := 281 - InfoRect[ i ].FRect.x;
  InfoRect[ i ].FRect.h := 264 - InfoRect[ i ].FRect.y;
  InfoRect[ i ].FInfo := GameFont.DrawText( TextMessage[ 43 ], 188, 268 );
   //pants
  inc( i );
  InfoRect[ i ].FRect.x := 113;
  InfoRect[ i ].FRect.y := 278;
  InfoRect[ i ].FRect.w := 281 - InfoRect[ i ].FRect.x;
  InfoRect[ i ].FRect.h := 306 - InfoRect[ i ].FRect.y;
  InfoRect[ i ].FInfo := GameFont.DrawText( TextMessage[ 44 ], 188, 268 );
   //hair color
  inc( i );
  InfoRect[ i ].FRect.x := 113;
  InfoRect[ i ].FRect.y := 321;
  InfoRect[ i ].FRect.w := 281 - InfoRect[ i ].FRect.x;
  InfoRect[ i ].FRect.h := 348 - InfoRect[ i ].FRect.y;
  InfoRect[ i ].FInfo := GameFont.DrawText( TextMessage[ 45 ], 188, 268 );
   //hair style
  inc( i );
  InfoRect[ i ].FRect.x := 113;
  InfoRect[ i ].FRect.y := 363;
  InfoRect[ i ].FRect.w := 281 - InfoRect[ i ].FRect.x;
  InfoRect[ i ].FRect.h := 391 - InfoRect[ i ].FRect.y;
  InfoRect[ i ].FInfo := GameFont.DrawText( TextMessage[ 46 ], 188, 268 );
   //beard
  inc( i );
  InfoRect[ i ].FRect.x := 113;
  InfoRect[ i ].FRect.y := 406;
  InfoRect[ i ].FRect.w := 281 - InfoRect[ i ].FRect.x;
  InfoRect[ i ].FRect.h := 434 - InfoRect[ i ].FRect.y;
  InfoRect[ i ].FInfo := GameFont.DrawText( TextMessage[ 47 ], 188, 268 );
  inc( i );
  InfoRect[ i ].FRect.x := 300;
  InfoRect[ i ].FRect.y := 132;
  InfoRect[ i ].FRect.w := 468 - InfoRect[ i ].FRect.x;
  InfoRect[ i ].FRect.h := 160 - InfoRect[ i ].FRect.y;
  InfoRect[ i ].FInfo := GameFont.DrawText( TextMessage[ 48 ], 188, 268 ); //  Fighting training places an emphasis on your '+
                     //'character''s combat ability, Scouting emphasizes your character''s stealth talents '+
                     //'and Magic emphasizes your character''s spellcasting ability.';

   //now for the selectable text
   //Shirt color
  i := 0;
  SelectRect[ i ].FRect.x := -148;
  SelectRect[ i ].FRect.y := 80;
  SelectRect[ i ].FRect.w := -186 - InfoRect[ i ].FRect.x;
  SelectRect[ i ].FRect.h := 101 - InfoRect[ i ].FRect.y;
  SelectRect[ i ].FInfo := GameFont.DrawText( TextMessage[ 49 ], 188, 268 );
  SelectRect[ i ].FText := GameFont.DrawText( TextMessage[ 70 ] );
  inc( i );
  SelectRect[ i ].FRect.x := -197;
  SelectRect[ i ].FRect.y := 80;
  SelectRect[ i ].FRect.w := -258 - InfoRect[ i ].FRect.x;
  SelectRect[ i ].FRect.h := 101 - InfoRect[ i ].FRect.y;
  SelectRect[ i ].FInfo := GameFont.DrawText( TextMessage[ 50 ], 188, 268 );
  SelectRect[ i ].FText := GameFont.DrawText( TextMessage[ 71 ] );
  inc( i );
  SelectRect[ i ].FRect.x := -269;
  SelectRect[ i ].FRect.y := 80;
  SelectRect[ i ].FRect.w := -320 - InfoRect[ i ].FRect.x;
  SelectRect[ i ].FRect.h := 101 - InfoRect[ i ].FRect.y;
  SelectRect[ i ].FInfo := GameFont.DrawText( TextMessage[ 51 ], 188, 268 );
  SelectRect[ i ].FText := GameFont.DrawText( TextMessage[ 72 ] );
  inc( i );
  SelectRect[ i ].FRect.x := -331;
  SelectRect[ i ].FRect.y := 80;
  SelectRect[ i ].FRect.w := -382 - InfoRect[ i ].FRect.x;
  SelectRect[ i ].FRect.h := 101 - InfoRect[ i ].FRect.y;
  SelectRect[ i ].FInfo := GameFont.DrawText( TextMessage[ 52 ], 188, 268 );
  SelectRect[ i ].FText := GameFont.DrawText( TextMessage[ 73 ] );
   //Pants color
  inc( i );
  SelectRect[ i ].FRect.x := -148;
  SelectRect[ i ].FRect.y := 110;
  SelectRect[ i ].FRect.w := -186 - InfoRect[ i ].FRect.x;
  SelectRect[ i ].FRect.h := 131 - InfoRect[ i ].FRect.y;
  SelectRect[ i ].FInfo := GameFont.DrawText( TextMessage[ 53 ], 188, 268 );
  SelectRect[ i ].FText := GameFont.DrawText( TextMessage[ 70 ] );
  inc( i );
  SelectRect[ i ].FRect.x := -197;
  SelectRect[ i ].FRect.y := 110;
  SelectRect[ i ].FRect.w := -258 - InfoRect[ i ].FRect.x;
  SelectRect[ i ].FRect.h := 131 - InfoRect[ i ].FRect.y;
  SelectRect[ i ].FInfo := GameFont.DrawText( TextMessage[ 54 ], 188, 268 );
  SelectRect[ i ].FText := GameFont.DrawText( TextMessage[ 71 ] );
  inc( i );
  SelectRect[ i ].FRect.x := -269;
  SelectRect[ i ].FRect.y := 110;
  SelectRect[ i ].FRect.w := -320 - InfoRect[ i ].FRect.x;
  SelectRect[ i ].FRect.h := 131 - InfoRect[ i ].FRect.y;
  SelectRect[ i ].FInfo := GameFont.DrawText( TextMessage[ 55 ], 188, 268 );
  SelectRect[ i ].FText := GameFont.DrawText( TextMessage[ 72 ] );
  inc( i );
  SelectRect[ i ].FRect.x := -331;
  SelectRect[ i ].FRect.y := 110;
  SelectRect[ i ].FRect.w := -382 - InfoRect[ i ].FRect.x;
  SelectRect[ i ].FRect.h := 131 - InfoRect[ i ].FRect.y;
  SelectRect[ i ].FInfo := GameFont.DrawText( TextMessage[ 56 ], 188, 268 );
  SelectRect[ i ].FText := GameFont.DrawText( TextMessage[ 73 ] );
   //hair color
  inc( i );
  SelectRect[ i ].FRect.x := -149;
  SelectRect[ i ].FRect.y := 140;
  SelectRect[ i ].FRect.w := -201 - InfoRect[ i ].FRect.x;
  SelectRect[ i ].FRect.h := 161 - InfoRect[ i ].FRect.y;
  SelectRect[ i ].FInfo := GameFont.DrawText( TextMessage[ 57 ], 188, 268 );
  SelectRect[ i ].FText := GameFont.DrawText( TextMessage[ 74 ] );
  inc( i );
  SelectRect[ i ].FRect.x := -210;
  SelectRect[ i ].FRect.y := 140;
  SelectRect[ i ].FRect.w := -271 - InfoRect[ i ].FRect.x;
  SelectRect[ i ].FRect.h := 161 - InfoRect[ i ].FRect.y;
  SelectRect[ i ].FInfo := GameFont.DrawText( TextMessage[ 58 ], 188, 268 );
  SelectRect[ i ].FText := GameFont.DrawText( TextMessage[ 71 ] );
  inc( i );
  SelectRect[ i ].FRect.x := -281;
  SelectRect[ i ].FRect.y := 140;
  SelectRect[ i ].FRect.w := -320 - InfoRect[ i ].FRect.x;
  SelectRect[ i ].FRect.h := 161 - InfoRect[ i ].FRect.y;
  SelectRect[ i ].FInfo := GameFont.DrawText( TextMessage[ 59 ], 188, 268 );
  SelectRect[ i ].FText := GameFont.DrawText( TextMessage[ 75 ] );
  inc( i );
  SelectRect[ i ].FRect.x := 329;
  SelectRect[ i ].FRect.y := 140;
  SelectRect[ i ].FRect.w := 373 - InfoRect[ i ].FRect.x;
  SelectRect[ i ].FRect.h := 161 - InfoRect[ i ].FRect.y;
  SelectRect[ i ].FInfo := GameFont.DrawText( TextMessage[ 60 ], 188, 268 );
  SelectRect[ i ].FText := GameFont.DrawText( TextMessage[ 76 ] );
   //Hair style
  inc( i );
  SelectRect[ i ].FRect.x := 149;
  SelectRect[ i ].FRect.y := 170;
  SelectRect[ i ].FRect.w := 196 - InfoRect[ i ].FRect.x;
  SelectRect[ i ].FRect.h := 191 - InfoRect[ i ].FRect.y;
  SelectRect[ i ].FInfo := GameFont.DrawText( TextMessage[ 61 ], 188, 268 );
  SelectRect[ i ].FText := GameFont.DrawText( TextMessage[ 77 ] );
  inc( i );
  SelectRect[ i ].FRect.x := 206;
  SelectRect[ i ].FRect.y := 170;
  SelectRect[ i ].FRect.w := 249 - InfoRect[ i ].FRect.x;
  SelectRect[ i ].FRect.h := 191 - InfoRect[ i ].FRect.y;
  SelectRect[ i ].FInfo := GameFont.DrawText( TextMessage[ 62 ], 188, 268 );
  SelectRect[ i ].FText := GameFont.DrawText( TextMessage[ 78 ] );
  inc( i );
  SelectRect[ i ].FRect.x := 259;
  SelectRect[ i ].FRect.y := 170;
  SelectRect[ i ].FRect.w := 331;
  SelectRect[ i ].FRect.h := 194;
  SelectRect[ i ].FInfo := GameFont.DrawText( TextMessage[ 63 ], 188, 268 );
  SelectRect[ i ].FText := GameFont.DrawText( TextMessage[ 79 ] );
  inc( i );
  SelectRect[ i ].FRect.x := 340;
  SelectRect[ i ].FRect.y := 170;
  SelectRect[ i ].FRect.w := 382 - InfoRect[ i ].FRect.x;
  SelectRect[ i ].FRect.h := 191 - InfoRect[ i ].FRect.y;
  SelectRect[ i ].FInfo := GameFont.DrawText( TextMessage[ 64 ], 188, 268 );
  SelectRect[ i ].FText := GameFont.DrawText( TextMessage[ 80 ] );
   //beard
  inc( i );
  SelectRect[ i ].FRect.x := 149;
  SelectRect[ i ].FRect.y := 200;
  SelectRect[ i ].FRect.w := 185 - InfoRect[ i ].FRect.x;
  SelectRect[ i ].FRect.h := 223 - InfoRect[ i ].FRect.y;
  SelectRect[ i ].FInfo := GameFont.DrawText( TextMessage[ 65 ], 188, 268 );
  SelectRect[ i ].FText := GameFont.DrawText( TextMessage[ 81 ] );
  inc( i );
  SelectRect[ i ].FRect.x := 194;
  SelectRect[ i ].FRect.y := 200;
  SelectRect[ i ].FRect.w := 239 - InfoRect[ i ].FRect.x;
  SelectRect[ i ].FRect.h := 223 - InfoRect[ i ].FRect.y;
  SelectRect[ i ].FInfo := GameFont.DrawText( TextMessage[ 66 ], 188, 268 );
  SelectRect[ i ].FText := GameFont.DrawText( TextMessage[ 82 ] );

  //Training
  inc( i );
  SelectRect[ i ].FRect.x := 40;
  SelectRect[ i ].FRect.y := 270;
  SelectRect[ i ].FRect.w := 113 - InfoRect[ i ].FRect.x;
  SelectRect[ i ].FRect.h := 293 - InfoRect[ i ].FRect.y;
  SelectRect[ i ].FInfo := GameFont.DrawText( TextMessage[ 67 ], 188, 268 );
  SelectRect[ i ].FText := GameFont.DrawText( TextMessage[ 83 ] );
  inc( i );
  SelectRect[ i ].FRect.x := 127;
  SelectRect[ i ].FRect.y := 270;
  SelectRect[ i ].FRect.w := 200 - InfoRect[ i ].FRect.x;
  SelectRect[ i ].FRect.h := 293 - InfoRect[ i ].FRect.y;
  SelectRect[ i ].FInfo := GameFont.DrawText( TextMessage[ 68 ], 188, 268 );
  SelectRect[ i ].FText := GameFont.DrawText( TextMessage[ 84 ] );
  inc( i );
  SelectRect[ i ].FRect.x := 216;
  SelectRect[ i ].FRect.y := 270;
  SelectRect[ i ].FRect.w := 270 - InfoRect[ i ].FRect.x;
  SelectRect[ i ].FRect.h := 293 - InfoRect[ i ].FRect.y;
  SelectRect[ i ].FInfo := GameFont.DrawText( TextMessage[ 69 ], 188, 268 );
  SelectRect[ i ].FText := GameFont.DrawText( TextMessage[ 85 ] );
d538 3
a540 2
procedure TNewGame.KeyDown( var Key : TSDLKey; Shift : TSDLMod;
  unicode : UInt16 );
d543 16
a558 10
  case Key of
    SDLK_RETURN :
      begin
        NextGameInterface := TMainMenu;
      end;

    SDLK_ESCAPE :
      begin
        NextGameInterface := TMainMenu;
      end;
a559 1
  MainWindow.Rendering := false;
d563 2
d568 21
a588 16
  //we store thse values so that we can keep the player from lowering his score beyon its start
  Damage := Character.Damage;
  Resistance := Character.Resistance;
  BaseStrength := Character.BaseStrength;
  BaseCoordination := Character.BaseCoordination;
  BaseConstitution := Character.BaseConstitution;
  BasePerception := Character.BasePerception;
  BaseCharm := Character.BaseCharm;
  BaseMysticism := Character.BaseMysticism;
  BaseCombat := Character.BaseCombat;
  BaseStealth := Character.BaseStealth;
  TrainingPoints := Character.TrainingPoints;

  for i := 0 to 7 do
  begin //initialize adjustments to zero
    StatAdjustments[ i ] := 0;
d593 2
d596 25
a620 20
  StatName[ 0 ][ 1 ] := TextMessage[ 86 ]; //'Strength';
  StatName[ 0 ][ 2 ] := TextMessage[ 87 ]; //'Coordination';
  StatName[ 0 ][ 3 ] := TextMessage[ 88 ]; //'Constitution';
  StatName[ 0 ][ 4 ] := TextMessage[ 89 ]; //'Perception';
  StatName[ 0 ][ 5 ] := TextMessage[ 90 ]; //'Charm';
  StatName[ 0 ][ 6 ] := TextMessage[ 91 ]; //'Mysticism';
  StatName[ 0 ][ 7 ] := TextMessage[ 92 ]; //'Combat';
  StatName[ 0 ][ 8 ] := TextMessage[ 93 ]; //'Stealth';

  StatName[ 1 ][ 1 ] := TextMessage[ 94 ]; //'Piercing';
  StatName[ 1 ][ 2 ] := TextMessage[ 95 ]; //'Crushing';
  StatName[ 1 ][ 3 ] := TextMessage[ 96 ]; //'Cutting';
  StatName[ 1 ][ 4 ] := TextMessage[ 97 ]; //'Heat';
  StatName[ 1 ][ 5 ] := TextMessage[ 98 ]; //'Cold';
  StatName[ 1 ][ 6 ] := TextMessage[ 99 ]; //'Electric';
  StatName[ 1 ][ 7 ] := TextMessage[ 100 ]; //'Poison';
  StatName[ 1 ][ 8 ] := TextMessage[ 101 ]; //'Magic';
  StatName[ 1 ][ 9 ] := TextMessage[ 102 ]; //'Mental';
  StatName[ 1 ][ 10 ] := TextMessage[ 103 ]; //'Stun';
  StatName[ 1 ][ 11 ] := TextMessage[ 104 ]; //'Special';
d624 2
d631 1
d633 1
a633 1
  Flags := SDL_SRCCOLORKEY or SDL_RLEACCEL or SDL_HWACCEL;
d635 5
a639 5
  ExText.Open( 'CharCreation' );
  for i := Low( TextMessage ) to High( TextMessage ) do
  begin
    TextMessage[ i ] := ExText.GetText( 'Message' + IntToStr( i ) );
  end;
d641 2
a642 2
  DXBack := SDL_LoadBMP( PChar( SoASettings.InterfacePath + '/' + SoASettings.LanguagePath + '/' + 'CharCreate.bmp' ) );
  SDL_SetColorKey( DXBack, Flags, SDL_MapRGB( DXBack.format, 0, 255, 255 ) );
d644 2
a645 2
  DXCircle := SDL_LoadBMP( PChar( SoASettings.InterfacePath + '/' + 'chaRedOval.bmp' ) );
  SDL_SetColorKey( DXCircle, Flags, SDL_MapRGB( DXCircle.format, 0, 255, 255 ) );
d647 2
a648 2
  DXBlack := SDL_LoadBMP( PChar( SoASettings.InterfacePath + '/' + 'chaBlack.bmp' ) );
  SDL_SetColorKey( DXBlack, Flags, SDL_MapRGB( DXBlack.format, 0, 255, 255 ) );
d650 25
a674 21
  DXBox := SDL_LoadBMP( PChar( SoASettings.InterfacePath + '/' + SoASettings.LanguagePath + '/' + 'chaChooseBox.bmp' ) );
  SDL_SetColorKey( DXBox, Flags, SDL_MapRGB( DXBox.format, 0, 255, 255 ) );

  DXContinue := SDL_LoadBMP( PChar( SoASettings.InterfacePath + '/' + SoASettings.LanguagePath + '/' + 'chaContinue.bmp' ) );
  SDL_SetColorKey( DXContinue, Flags, SDL_MapRGB( DXContinue.format, 0, 255, 255 ) );

  DXCancel := SDL_LoadBMP( PChar( SoASettings.InterfacePath + '/' + SoASettings.LanguagePath + '/' + 'chaCancel.bmp' ) );
  SDL_SetColorKey( DXCancel, Flags, SDL_MapRGB( DXCancel.format, 0, 255, 255 ) );

  ContinueRect.x := 400;
  ContinueRect.y := 449;
  ContinueRect.w := DXContinue.w;
  ContinueRect.h := DXContinue.h;

  CancelRect.x := 100;
  CancelRect.y := 449;
  CancelRect.w := DXCancel.w;
  CancelRect.h := DXCancel.h;

  LoadNames;
  CreateCollisionRects;
d678 2
d682 17
a698 12
  if PointIsInRect( CurrentPos, 452, 133, 467, 159 ) then
    ixSelectedTraining := ShowListBox( 313, 175, moTrainingStyle )
  else if PointIsInRect( CurrentPos, 265, 239, 279, 264  ) then
    ixSelectedShirt := ShowListBox( 280, 239, moShirtColour )
  else if PointIsInRect( CurrentPos, 265, 280, 279, 295 ) then
    ixSelectedPants := ShowListBox( 280, 281, moPantsColour )
  else if PointIsInRect( CurrentPos, 265, 322, 279, 337 ) then
    ixSelectedHair := ShowListBox( 280, 323, moHairColour )
  else if PointIsInRect( CurrentPos, 265, 364, 279, 379 ) then
    ixSelectedHairStyle := ShowListBox( 280, 365, moHairStyle )
  else if PointIsInRect( CurrentPos, 265, 408, 279, 423 ) then
    ixSelectedBeard := ShowListBox( 280, 409, moBeard );
d701 3
a703 2
procedure TNewGame.MouseMove( Shift : TSDLMod; CurrentPos,
  RelativePos : TPoint );
d706 10
a715 5
  MouseOverOptions := moNone;
  if PointIsInRect( CurrentPos, ContinueRect.x, ContinueRect.y, ContinueRect.x + ContinueRect.w, ContinueRect.y + ContinueRect.h ) then
    MouseOverOptions := moContinue
  else if PointIsInRect( CurrentPos, CancelRect.x, CancelRect.y, CancelRect.x + CancelRect.w, CancelRect.y + CancelRect.h ) then
    MouseOverOptions := moCancel;
d719 2
d723 15
a737 10
  case MouseOverOptions of
    moContinue :
      begin
        SDL_BlitSurface( DXContinue, nil, MainWindow.DisplaySurface, @@ContinueRect );
      end;

    moCancel :
      begin
        SDL_BlitSurface( DXCancel, nil, MainWindow.DisplaySurface, @@CancelRect );
      end;
a738 2


d742 2
d748 1
a748 3
  iLow := 0;
  iHigh := 3;
  ListBoxDialog := TListBoxDialog.Create( SoAoSGame, aX, aY );
d750 40
a789 5
    case aMoOptions of
      moShirtColour :
      begin
        iLow := 0;
        iHigh := 3;
d792 3
a794 1
      moPantsColour :
d796 3
a798 26
        iLow := 4;
        iHigh := 7;
      end;

      moHairColour :
      begin
        iLow := 8;
        iHigh := 11;
      end;

      moHairStyle :
      begin
        iLow := 12;
        iHigh := 15;
      end;

      moBeard :
      begin
        iLow := 16;
        iHigh := 17;
      end;

      moTrainingStyle :
      begin
        iLow := 18;
        iHigh := 20;
d800 6
d807 4
a810 15

    x := 0;
    SetLength( ListBoxDialog.ListItems, iHigh - iLow );
    for i := iLow to iHigh do
    begin
      ListBoxDialog.ListItems[ x ].FInfo := SelectRect[ i ].FInfo;
      ListBoxDialog.ListItems[ X ].FText := SelectRect[ i ].FText;
      inc( x );
    end;
    
    ListBoxDialog.LoadSurfaces;
    SoAoSGame.Show;
    Result := ListBoxDialog.SelectedIndex;
  finally
    ListBoxDialog.Free;
a811 1
  ResetInputManager;
@


1.3
log
@Latest code changes
@
text
@@


1.2
log
@Initial changes to stop it crashing on exit.
@
text
@d62 3
d76 3
a78 1
  SiegeInterfaces;
d91 1
a91 1
    moTraingStyle,
d112 24
d151 20
d173 1
d175 1
a175 1
    //Character : TCharacter;
d189 2
a190 1
  GameMainMenu;
d471 2
a472 1
   //Training
d545 23
d634 3
d642 12
a653 2
  NextGameInterface := TMainMenu;
  MainWindow.Rendering := false;
d685 65
@


1.1
log
@Initial Game Interface units.
@
text
@d62 3
d76 31
d114 10
d125 1
d137 3
a139 1
  globals;
d143 301
d445 2
d453 19
d479 13
d493 22
d519 1
d526 7
a532 1
  DXBack := SDL_LoadBMP( PChar( SoASettings.InterfacePath + '/' + 'CharCreate.bmp' ) );
d541 1
a541 1
  DXBox := SDL_LoadBMP( PChar( SoASettings.InterfacePath + '/' + 'chaChooseBox.bmp' ) );
d544 1
a544 1
  DXContinue := SDL_LoadBMP( PChar( SoASettings.InterfacePath + '/' + 'chaContinue.bmp' ) );
d547 1
a547 1
  DXCancel := SDL_LoadBMP( PChar( SoASettings.InterfacePath + '/' + 'chaCancel.bmp' ) );
d550 9
d561 1
a561 2
procedure TNewGame.MouseDown( Button : Integer; Shift : TSDLMod;
  CurrentPos : TPoint );
d564 2
a565 1

d572 5
a576 1

d582 12
d598 1
@

